[{"content":"Gin官网\nGin 是一个用 Go (Golang) 编写的 HTTP Web 框架\n安装 使用 go get -u 下载最新的 gin 包, 同时把依赖信息写入 go.mod\n1 2 3 4 5 $ go env -w GOPROXY=https://goproxy.cn,direct # 设置 go 下载源为国内源 $ go get -u github.com/gin-gonic/gin # -u 强制使用网络下载安装 Gin 依赖包 $ go list -m all | grep gin \u0026gt; github.com/gin-gonic/gin v1.9.1 示例 1 2 3 4 5 6 7 8 9 $ go mod init web # 初始化 web 项目 $ touch main.go # 创建项目入口文件 $ go get -u github.com/gin-gonic/gin # 安装 gin 框架 $ ls -l total 24 \u0026gt; -rw-r--r-- 1 root root 2265 Jul 19 02:45 go.mod \u0026gt; -rw-r--r-- 1 root root 15259 Jul 19 02:45 go.sum \u0026gt; -rw-r--r-- 1 root root 234 Jul 19 03:18 main.go 编辑 main.go 文件，添加代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; // 引入 gin \u0026#34;net/http\u0026#34; ) func main() { engine := gin.Default() // 实例化 engine 对象 engine.GET(\u0026#34;/\u0026#34;, webRoot) // 注册路由 / 及其处理函数 engine.GET(\u0026#34;/index\u0026#34;, webIndex) // 注册路由 /index 及其处理函数 engine.Run(\u0026#34;:8080\u0026#34;) // 启动服务, 监听 8080 端口 } func webRoot(context *gin.Context) { context.String(http.StatusOK, \u0026#34;this is root page\u0026#34;) } func webIndex(context *gin.Context) { context.String(http.StatusOK, \u0026#34;this is index page\u0026#34;) } 执行 main.go\n1 2 3 4 5 6 $ go run main.go \u0026gt; ...... \u0026gt; [GIN-debug] GET / --\u0026gt; main.webRoot (3 handlers) \u0026gt; [GIN-debug] GET /index --\u0026gt; main.webIndex (3 handlers) \u0026gt; ...... \u0026gt; [GIN-debug] Listening and serving HTTP on :8080 路由参数 Github 个人主页 http://github.com/{username}, 替换不同用户名即可进入不同用户的 Github 主页 网址中的 username 就是路由参数, 后台服务拿到 username 的实际值然后返回该用户的信息\nGin 通过 Param() 或 Params 获取路由中的参数\n1 2 3 4 5 func (c *Context) Param(key string) string // Param 返回 string 类型 type Params []Param func (ps Params) ByName(name string) (va string) // Params 的参数查找方法 func (ps Params) Get(name string) (string, bool) // Params 的参数查找方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { ... engine.GET(\u0026#34;/index/:id\u0026#34;, routeParam) // 注册路由和对应函数 engine.GET(\u0026#34;/group/:name\u0026#34;, routeParams) ... } func routeParam(c *gin.Context) { // index 任意子界面 id := c.Param(\u0026#34;id\u0026#34;) // Param 获取路由参数的值 c.String(200, \u0026#34;id: %s\u0026#34;, id) } func routeParams(c *gin.Context) { // group 任意子界面 n, err := c.Params.Get(\u0026#34;name\u0026#34;) // Params.Get 获取路由参数值 m := c.Params.ByName(\u0026#34;name\u0026#34;) // Params.ByName 获取路由参数值 c.String(200, \u0026#34;n: %s m: %s\u0026#34;, n, m) } Query 参数 网址 https://github.com/facsert?tab=repositories 中 ? 后的便是 Quary 参数, 参数形式 key=value, 通过 \u0026amp; 分隔\nGin 通过以下方法获取 query 参数\n1 2 3 4 5 6 func (c *Context) GetQuery(key string) (string, bool) func (c *Context) Query(key string) string func (c *Context) DefaultQuery(key, defaultValue string) string func (c *Context) GetQueryArray(key string) ([]string, bool) func (c *Context) QueryArray(key string) []string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { ... engine.GET(\u0026#34;/index/\u0026#34;, routeQuerys) // 注册路由和对应函数 engine.GET(\u0026#34;/group/\u0026#34;, routeQuery) ... } func routeQuerys(c *gin.Context) { // http://localhost:8080/index?id=4 id := c.QueryArry(\u0026#34;id\u0026#34;) // 获取 queray 参数值列表 c.String(200, \u0026#34;id: %v\u0026#34;, id) // id: [4] } func routeQuery(c *gin.Context) { // http://localhost:8080/group?name=jack n, err := c.DefaultQuery(\u0026#34;name\u0026#34;, \u0026#34;nobody\u0026#34;) // 未获取到则使用默认值 nobody m := c.Query(\u0026#34;name\u0026#34;) // query 获取参数值 c.String(200, \u0026#34;n: %s m: %s\u0026#34;, n, m) // n: jack m: jack } Form 参数 Form 表单数据存储在 POST 请求体中, 请求体格式: application/x-www-form-urlencoded\n1 2 3 4 5 6 7 8 9 func (c *Context) PostForm(key string) string func (c *Context) DefaultPostForm(key, defaultValue string) stri func (c *Context) GetPostForm(key string) (string, bool) func (c *Context) PostFormMap(key string) map[string]string func (c *Context) PostFormArray(key string) []string func (c *Context) GetPostFormArray(key string) ([]string, bool) func (c *Context) GetPostFormMap(key string) (map[string]string, bool) 1 2 3 4 5 6 7 8 9 10 11 func main() { ... engine.POST(\u0026#34;/table/\u0026#34;, table) // 注册路由和对应函数 ... } func table(c *gin.Context) { // curl -X \u0026#39;POST\u0026#39; http://localhost:8080/table name := c.PostForm(\u0026#34;name\u0026#34;) // -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; age := c.PostForm(\u0026#34;age\u0026#34;) // -d \u0026#39;name=lily\u0026amp;age=16\u0026#39; c.String(200, \u0026#34;name:%s age:%s\u0026#34;, name, age) // name:lily age:16 } JSON 参数 JSON 数据存储在 POST 请求体中, 请求体 application/json, 获取原始数据后格式化转 map\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { ... engine.POST(\u0026#34;/raw/\u0026#34;, rawData) // 注册路由和对应函数 ... } func rawData(c *gin.Context) { // curl -X \u0026#39;POST\u0026#39; http://localhost:8080/raw data, _ := c.GetRawData() // -H \u0026#39;Content-Type: application/json\u0026#39; var m map[string]any // -d \u0026#39;{name:lily, age:16}\u0026#39; _ = json.Unmarshal(data, \u0026amp;m) c.String(200, \u0026#34;Json: %#v\u0026#34;, m) // Json: map[string]interface {}{\u0026#34;age\u0026#34;:\u0026#34;14\u0026#34;, \u0026#34;user\u0026#34;:\u0026#34;petter\u0026#34;} } 参数绑定 基于请求类型开发接口比较麻烦, 且多种参数都是 key-valuse 形式, 于是有了自适应解析 定义一个结构体, 将请求体字段与结构体属性绑定, 通过 ShouldBind 赋值给结构体属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Person struct { // 结构体属性开头大写, 允许外部使用 Name string `json:\u0026#34;name\u0026#34; form:\u0026#34;name\u0026#34; binding:\u0026#34;required\u0026#34;` Age string `json:\u0026#34;age\u0026#34; form:\u0026#34;age\u0026#34; binding:\u0026#34;required\u0026#34;` } func main() { engine := gin.Default() engine.POST(\u0026#34;/model\u0026#34;, func(c *gin.Context) { // Body {\u0026#34;age\u0026#34;: \u0026#34;16\u0026#34;,\u0026#34;name\u0026#34;: \u0026#34;lily\u0026#34;} var p Person err := c.ShouldBind(\u0026amp;p) // 自适应解析 if err != nil { c.String(400, \u0026#34;login fail\u0026#34;) } c.String(200, \u0026#34;login info: %#v\u0026#34;, p) // login info: main.Person{Name:\u0026#34;Bob\u0026#34;, Age:\u0026#34;16\u0026#34;} }) } 文件上传 ","date":"2023-07-12T09:29:19Z","permalink":"https://facsert.github.io/p/gin/","title":"Gin"},{"content":"介绍 Bash 所有代码除关键字外默认为字符串\n1 2 3 4 5 6 7 8 9 $ command=\u0026#34;date\u0026#34; $ $command # 取 command 变量值 \u0026#34;date\u0026#34;, \u0026#34;date\u0026#34; 作为命令执行 \u0026gt; Mon Jun 12 10:07:40 CST 2023 # 执行 date, 打印日期 $ echo date # date 被当作字符串, 作为 echo 的参数 \u0026gt; date $ echo $(\u0026#34;date\u0026#34;) # 执行 \u0026#34;date\u0026#34;, 返回值作为 echo 的参数 \u0026gt; Mon Jun 12 10:23:46 CST 2023 Bash 默认第一个字符为指令, 后续值为字符串作为指令的参数\n长度 ${#s} 返回字符串的长度\n1 2 3 $ s=\u0026#34;123 456\u0026#34;; s=\u0026#34;456 123\u0026#34; # 赋值 $ echo \u0026#34;s:${s} length: ${#s}\u0026#34; # 获取长度 \u0026gt; s:456 123 length: 7 # 打印 子字符串 ${s:start:length}\n1 2 3 $ s=\u0026#34;01234\u0026#34; $ echo \u0026#34;${s:0:3}\u0026#34; # 从序号 0 开始, 获取 3 个长度 \u0026gt; 012 # 删除和替换 字符串通过 #(开头开始匹配) %(结尾开始匹配) 完成删除或替换操作\n删除: ${variable#pattern} ${variable##pattern} ${variable%pattern} ${variable%%pattern} 替换: ${variable/pattern/string} ${variable//pattern/string}\n1 2 3 4 5 6 7 8 9 10 11 12 $ date=\u0026#34;2023-07-31\u0026#34; $ echo ${date#*-} ${date##*-} # # 从开头开始匹配, 只匹配最短内容 ## 贪婪匹配 \u0026gt; 07-31 31 $ echo ${date%-*} ${date%%-*} # % 从结尾开始匹配, 只匹配最短内容 %% 贪婪匹配 \u0026gt; 2023-07 2023 $ echo ${date/-/=} # 只替换一次 \u0026gt; 2024=07-31 $ echo ${date//-/=} # 全替换 \u0026gt; 2023=07=01 大小写 ${variable^^} 字母全替换为大写\n${variable,,} 字母全替换为小写\n1 2 3 4 5 6 $ var=\u0026#34;ABC123xyz\u0026#34; $ echo ${var^^} \u0026gt; ABC123XYZ $ echo ${var,,} \u0026gt; abc123xyz ","date":"2023-07-10T21:20:45Z","permalink":"https://facsert.github.io/p/bash-%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Bash 字符串"},{"content":"安装 下载 swagger 关联的库\n1 2 3 4 5 6 7 $ go get -u github.com/swaggo/swag/cmd/swag # 命令行工具 $ go get -u github.com/swaggo/gin-swagger $ go get -u github.com/swaggo/files $ go install github.com/swaggo/swag/cmd/swag # 编译生产可执行文件放入$GOPATH/bin $ swag -v \u0026gt; swag version v1.8.12 添加注释并拉起服务后，浏览器访问 http://\u0026lt;host\u0026gt;:\u0026lt;port\u0026gt;/swagger/index.html\n通用注解 go swagger 通过注释绑定接口设置和显示内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; // 引入 gin swaggerFiles \u0026#34;github.com/swaggo/files\u0026#34; ginSwagger \u0026#34;github.com/swaggo/gin-swagger\u0026#34; \u0026#34;net/http\u0026#34; _ \u0026#34;swag/docs\u0026#34; // \u0026lt;projectName\u0026gt;/docs swag 替换为项目名称 ) // @title Swagger // @version 1.0.0 // @description Swagger Test // @host 10.58.14.96:8080 // @BasePath / // @schemes http https // @contact.name facsert // @contact.url https://facsert.github.io/ // @contact.email facsert@outlook.com // @termsOfService http://swagger.io/terms/ // @license.name Apache 2.0 // @license.url http://www.apache.org/licenses/LICENSE-2.0.html func main() { engine := gin.Default() engine.GET(\u0026#34;/root\u0026#34;, webRoot) engine.GET(\u0026#34;/index\u0026#34;, webIndex) engine.GET(\u0026#34;/swagger/*any\u0026#34;, ginSwagger.WrapHandler(swaggerFiles.Handler)) engine.Run(\u0026#34;:8080\u0026#34;) } 字段 说明 示例 @title (必填)大标题 Swagger @version (必填)版本 1.0.0 @description 描述 Swagger Test @host 运行服务主机 IP 地址 10.58.14.96:8080 @BasePath API基本路径(会添加在所有API路由前) / @schemes 请求的传输协议 http https @contact.name 联系人信息 facsert @contact.url 联系人信息网址 https://facsert.github.io/ @contact.email 联系人邮件 facsert@outlook.com @termsOfService API服务条款 http://swagger.io/terms/ @license.name (必填)API许可证名称 Apache 2.0 @license.url API许可证网址 http://www.apache.org/licenses/LICENSE-2.0.html 部分字段如 @title @version @license.name 是必填字段，字段首字母不区分大小写 其余字段可填，可不填写\nAPI注解 1 2 3 4 5 6 7 8 9 10 // @tags Router // @id root // @summary \u0026#34;root page\u0026#34; // @Produce json // @Success 200 {object} string \u0026#34;response with root page\u0026#34; // @Failure 400 {object} string \u0026#34;response with root page fail\u0026#34; // @Router / [get] func webRoot(context *gin.Context) { context.String(http.StatusOK, \u0026#34;this is root page\u0026#34;) } 字段 说明 示例 @tags 一组API的组名 User @id API唯一标识 root page @summary API简短描述 show info @Router (必填)路由和请求方法 /root/user [get] @Param 接口参数 name path string true \u0026quot;username\u0026quot; @Accept 请求体的MIME类型数据 json @Produce 响应体的MIME类型数据 json @Success 响应成功内容 200 {object} string \u0026quot;response success\u0026quot; @Failure 响应失败内容 400 {object} string \u0026quot;response fail\u0026quot; @Response 响应失败内容 500 {object} string \u0026quot;response fail\u0026quot; 部分字段如 @Router 是必填字段，缺失则不显示，字段首字母不区分大小写 其余字段根据不同接口影响功能测试\nMIME 类型 MIME 类型即请求体和响应体的类型\n1 2 3 4 5 6 // @Accept application/json 请求体是 json 类型数据 // @Accept application/xml 请求体是 XML 格式数据 // @Accept application/x-www-form-urlencoded 请求体是表单类型 // @Produce text/plain 响应纯文本数据 // @Produce text/html 响应 HTML 数据 // @Produce application/octet-stream 响应二进制流数据, 返回客户端需要下载的文件 响应 @Response {return Code} {param type} {date type} commit\n1 2 3 4 // @Success 200 {array} model.Account // @Header 200 {string} Token \u0026#34;qwerty\u0026#34; // @Failure 400,404 {object} httputil.HTTPError // @Failure default {object} httputil.DefaultError 参数 @Parma name locate type need description attribute API 参数信息和约束\nname: 参数名 locate: 参数位置（path, query, header, body 或 formData） type: 参数的数据类型(可以使用自定义类型) need: 是否必须 description: 参数的描述 attribute: 属性(选填), 根据类型可以限定最大最小值, 长度, 格式等 1 2 3 4 5 // @Param userId path int true \u0026#34;UserID\u0026#34; minimum(0) minimum(9) // @Param username query string true \u0026#34;Username\u0026#34; minLength(0) maxLength(9) // @Param levle path int true \u0026#34;Levle\u0026#34; enums(1, 2, 3) // @Param user body User true \u0026#34;User\u0026#34; // @Param file formData file true \u0026#34;File upload\u0026#34; 路由 @Router path [httpMethod]\n静态路由: 固定路由，不会发生改变\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { ... engine.GET(\u0026#34;/index/static\u0026#34;, static) ... } // @Tags User // @summary static router // @Router /index/static [get] func static(c *gin.Context) { c.String(http.StatusOK, \u0026#34;static page\u0026#34;) } 动态路由: 路由中存在参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { ... engine.GET(\u0026#34;/index/:name/:attribute\u0026#34;, detail) ... } // @Tags User // @summary user api // @Param name path string true \u0026#34;name\u0026#34; // @Param attribute path string true \u0026#34;attribute name\u0026#34; // @Router /index/{name}/{attribute} [get] func detail(c *gin.Context) { name := c.Param(\u0026#34;name\u0026#34;) attr := c.Param(\u0026#34;attribute\u0026#34;) c.String(http.StatusOK, \u0026#34;name:%s attribute:%s\u0026#34;, name, attr) } ","date":"2023-04-19T19:26:24Z","permalink":"https://facsert.github.io/p/go-swagger/","title":"Go Swagger"},{"content":"Struct struct 初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type \u0026lt;struct name\u0026gt; struct { // 定义结构体, 结构体可以认为是自定义的数据类型 \u0026lt;attribute name\u0026gt; \u0026lt;type\u0026gt; // 定义结构体属性及其类型 \u0026lt;attribute name\u0026gt; \u0026lt;type\u0026gt; // 每个属性名唯一, 不能重复 ... } type Student struct { // 定义 Student 类型数据 name, city string // Student 类型有 name city 属性, 属性值为 string age int // Student 类型有 age 属性, 属性类型为 int } var kertory Student // 初始化 Student 类型变量 kertory kertory.name = \u0026#34;kertory\u0026#34; // 使用 . 赋值 kertory.age = 18 facsert := Student{ // 初始化 Student 类型变量 facsert name: \u0026#34;facsert\u0026#34;, city: \u0026#34;shanghai\u0026#34;, } Printf(\u0026#34;%#v\\n\u0026#34;, kertory) Printf(\u0026#34;%#v\\n\u0026#34;, facsert) \u0026gt; main.Student{name:\u0026#34;kertory\u0026#34;, city:\u0026#34;\u0026#34;, age:18} // 未初始化的属性使用类型的零值 \u0026gt; main.Student{name:\u0026#34;facsert\u0026#34;, city:\u0026#34;shanghai\u0026#34;, age:0} struct 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 type Student struct { name, city string age int } func (s Student) Learn() { Printf(\u0026#34;%s learnig in %s\\n\u0026#34;, s.name, s.city) } func (s Student) Play() { Printf(\u0026#34;%s play games\\n\u0026#34;, s.name) } facsert := Student{ name: \u0026#34;facsert\u0026#34;, city: \u0026#34;shanghai\u0026#34;, } facsert.Learn() facsert.Play() \u0026gt; facsert learnig in shanghai \u0026gt; facsert play games struct 属性修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type Student struct { name, city string age int } func (s Student) rename1(name string) { // 重命名属性 name s.name = name Printf(\u0026#34;rename1 to %s\\n\u0026#34;, s.name) } func (s *Student) rename2(name string) { // 重命名属性 name s.name = name Printf(\u0026#34;rename2 to %s\\n\u0026#34;, s.name) } facsert := Student{ name: \u0026#34;facsert\u0026#34;, city: \u0026#34;shanghai\u0026#34;, } facsert.rename1(\u0026#34;kertory\u0026#34;) facsert.rename2(\u0026#34;squtary\u0026#34;) Printf(\u0026#34;name: %s\\n\u0026#34;, facsert.name) \u0026gt; rename1 to kertory // 重命名结果只在函数内生效 \u0026gt; rename2 to squtary // 重命名结果对结构体生效 \u0026gt; name: squtary struct 转 json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import ( . \u0026#34;fmt\u0026#34; \u0026#34;encoding/json\u0026#34; ) type Student struct { Name string // 属性名大写其它模块可访问, 可以转 json city string // 属性名小写其它模块不能访问也不能转 json Age int `json:\u0026#34;age\u0026#34;` // 可以通过定义 tag, 修改转化为 json 后 key 名称 } facsert := Student{ Name: \u0026#34;facsert\u0026#34;, city: \u0026#34;shanghai\u0026#34;, Age: 18, } jsonStu, err := json.Marshal(facsert) // struct 转 json if err != nil { panic(\u0026#34;json mashal failed\u0026#34;) } Println(facsert) Println(string(jsonStu)) \u0026gt; {facsert shanghai 18} // facsert 结构体所有属性值 \u0026gt; {\u0026#34;Name\u0026#34;:\u0026#34;facsert\u0026#34;,\u0026#34;age\u0026#34;:18} // city 属性不在, Age 属性名变为 age ","date":"2023-04-19T19:26:24Z","permalink":"https://facsert.github.io/p/go-%E7%BB%93%E6%9E%84%E4%BD%93/","title":"Go 结构体"},{"content":"if else 分支 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 if expression { branch } else if expression { branch } else { branch } done := false if done { Println(\u0026#34;done, goodbye\u0026#34;) } else { Println(\u0026#34;not done, continue\u0026#34;) } if done := true; done { Println(\u0026#34;done, goodbye\u0026#34;) } else { Println(\u0026#34;not done, continue\u0026#34;) } for 循环 1 2 3 4 5 6 7 8 9 10 11 for initial; expression; end { loop } for i:= 0; i \u0026lt; 3; i++ { Printf(\u0026#34;index: %d\\n\u0026#34;, i) } \u0026gt; index: 0 \u0026gt; index: 1 \u0026gt; index: 2 for range 遍历数组, 切片, map\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 intSlice := []int{0, 1} for index, elem := range intSlice { // 数组和切片会返回索引和值 Printf(\u0026#34;%d: %d\\n\u0026#34;, index, elem) } \u0026gt; 0: 0 \u0026gt; 1: 1 intMap := map[string]int{ \u0026#34;1st\u0026#34;: 1, \u0026#34;2nd\u0026#34;: 2, } for key, value := range intMap { // map 会返回 key 和 value Printf(\u0026#34;%s: %d\\n\u0026#34;, key, value) } \u0026gt; 2nd: 2 \u0026gt; 1st: 1 continue 提前结束本次循环, 直接进入下一次循环\n1 2 3 4 5 6 7 8 9 for i:=0; i \u0026lt; 3; i++ { if i == 1 { // 当 i == 1， 使用 continue 提前结束 continue // 提前结束本次循环, 进入下一个循环 } Println(i) } \u0026gt; 0 \u0026gt; 2 break 结束最近的一层循环, 一个 break 结束一个 for 循环\n1 2 3 4 5 6 7 8 for i:=0; i \u0026lt; 3; i++ { if i == 1 { // 当 i == 1， 使用 break 结束循环 break // break 只能跳出一层循环 } Println(i) } \u0026gt; 0 goto 设置 tag, 跳出复杂逻辑到 tag 语句\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 for i:=0; i \u0026lt; 3; i++ { for j := 0; j \u0026lt; 3; j++ { if i == 1 \u0026amp;\u0026amp; j == 0 { Printf(\u0026#34;loop over i:%d j:%d\\n\u0026#34;, i, j) goto breakTwoLoop // 从复杂结构中跳到 tag 对应的语句 } Printf(\u0026#34;i:%d j:%d\\n\u0026#34;, i, j) } } breakTwoLoop: // 设置 tag 及执行语句, 提供可跳跃点 Println(\u0026#34;Get out of loop\u0026#34;) \u0026gt; i:0 j:0 \u0026gt; i:0 j:1 \u0026gt; i:0 j:2 \u0026gt; loop over i:1 j:0 \u0026gt; Get out of loop switch case 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 switch expression { case branch: code case branch: code case branch: code default: code } switch nun := 3; num { // 值选择分支 case 1,3,5,7,9: // 单个分支可容纳多个值 Println(\u0026#34;奇数\u0026#34;) case 2,4,6,8: // 每个分支自带 break, 执行完分支即退出 switch Println(\u0026#34;偶数\u0026#34;) default: Println(\u0026#34;超出范围\u0026#34;) } \u0026gt; 奇数 grade := 80 switch { // 表达式选择分支, 变量需要在 switch 外初始化 case grade \u0026gt;= 0 \u0026amp;\u0026amp; grade \u0026lt; 60: Println(\u0026#34;不及格, 好好努力\u0026#34;) case grade \u0026gt;= 60 \u0026amp;\u0026amp; grade \u0026lt; 80: Println(\u0026#34;不错的成绩, 继续加油!\u0026#34;) case grade \u0026gt;= 80 \u0026amp;\u0026amp; grade \u0026lt;= 100: Println(\u0026#34;很棒哦!\u0026#34;) default: Println(\u0026#34;分数错误\u0026#34;) } \u0026gt; 很棒哦! ","date":"2023-04-19T19:21:24Z","permalink":"https://facsert.github.io/p/go-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"Go 流程控制"},{"content":"function 定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func \u0026lt;function name\u0026gt; (\u0026lt;parameter name\u0026gt; \u0026lt;parameter type\u0026gt;) (\u0026lt;return type\u0026gt;) { \u0026lt;functuion code\u0026gt; } func show() { // 无参数, 无返回值, 对应内容不填 Println(\u0026#34;no parameter and no return\u0026#34;) } func add(x int, y int) int { // 参数和类型要对应 return x + y } func self(x, y int) (int, int) { // 同类型参数合并, 多返回值, 返回值类型需要括号 return x, y } func: 函数定义使用的关键字 function name: 函数名, 同变量使用 parameter name: 参数名, 参数名与类型成对存在 parameter type: 参数类型, 多个同类型参数可只写 1 次 return type: 返回值的类型 golang 强制规定左花括号必须和 func 同一行 参数与返回值 golang 允许不定数量的参数 golang 允许多个返回值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func sum(nums ...int) int { // 设置可变参数, 可变参数通常作为最后一个参数 res := 0 for _, i := range nums { // 可变参数本质是一个切片 res += i } return res } Println(sum(1,2,3,4)) \u0026gt; 10 func calc(x, y int) (sum, sub int) { // 指定多个返回值 sum := x + y sub = x - y return } func add(x, y int) (int, int) { // 多个返回值时, 返回值类型需要带括号 return x+1, y+1 } 匿名函数 golang 允许将函数赋值给变量 golang 允许函数不定义名称直接运行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 average := func(x, y int) int { return (x+y)/2 } Println(average(6, 8)) \u0026gt; 7 avg := func(x, y int) int { return (x+y)/2 }(3,5) Println(avg) \u0026gt; 4 defer defer 关键字会将之后语句或函数放到函数结尾运行 多个 defer 语句按照先进后出的顺序执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func delay() { defer func() { // 将函数延迟到最后执行 Println(\u0026#34;third print\u0026#34;) }() Println(\u0026#34;first print\u0026#34;) Println(\u0026#34;second print\u0026#34;) } \u0026gt; first print // first second 正常按顺序打印 \u0026gt; second print \u0026gt; third print // third 延迟到最后打印 func stack() { // 执行多个 defer 语句 defer Println(\u0026#34;4th\u0026#34;) defer Println(\u0026#34;3rd\u0026#34;) defer Println(\u0026#34;2nd\u0026#34;) defer Println(\u0026#34;1st\u0026#34;) } \u0026gt; 1st // 多个 defer 按照先进后出的顺序执行 \u0026gt; 2nd \u0026gt; 3rd ","date":"2023-03-28T19:26:24Z","permalink":"https://facsert.github.io/p/go-%E5%87%BD%E6%95%B0/","title":"Go 函数"},{"content":"Map map 是一组无序的键值对的集合\nmap 是引用类型, 赋值时传递的是地址\nmap 初始化 map 只声明不初始化取零值 nil, nil map 只能读不能写入\nmap 初始化未添加值是 empty map, empty map 不等于 nil map\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 map[\u0026lt;key type\u0026gt;]\u0026lt;value type\u0026gt; // map 类型 var strMap = make(map[string]string, 1) // 声明并初始化一个 empty map, map 容量为 2 strMap[\u0026#34;a\u0026#34;] = \u0026#34;a\u0026#34; // 已初始化的 map 赋值 strMap[\u0026#34;b\u0026#34;] = \u0026#34;b\u0026#34; intMap := map[string]int { // intMap 声明并初始化, 并赋值 \u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, } Printf(\u0026#34;int map %#v\\n\u0026#34;, intMap) Printf(\u0026#34;str map %#v\\n\u0026#34;, strMap) Printf(\u0026#34;str map length %v\\n\u0026#34;, len(strMap)) \u0026gt; int map map[string]int{\u0026#34;one\u0026#34;:1, \u0026#34;two\u0026#34;:2} \u0026gt; str map map[string]string{\u0026#34;a\u0026#34;:\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;:\u0026#34;b\u0026#34;} // map 可添加数据, 允许超过容量 \u0026gt; str map length 3 // 无法使用 cap 查看 map 容量, 可以使用 len 查看长度 map 传递 map 将引用拷贝了一份给赋值变量, 两个引用指向同一个数据\nmap 作为函数参数传递时也是拷贝一份引用进入函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 intMap := map[string]int { \u0026#34;1st\u0026#34;: 1, } copyMap := intMap // map 是引用类型, 传递的是引用并非数据的拷贝 copyMap[\u0026#34;2nd\u0026#34;] = 2 intMap[\u0026#34;1st\u0026#34;] = 4 Printf(\u0026#34;intMap %#v\\n\u0026#34;, intMap) Printf(\u0026#34;copyMap %#v\\n\u0026#34;, copyMap) \u0026gt; intMap map[string]int{\u0026#34;1st\u0026#34;:4, \u0026#34;2nd\u0026#34;:2} // 任意一个变量修改数据, 两个变量都会同步修改 \u0026gt; copyMap map[string]int{\u0026#34;1st\u0026#34;:4, \u0026#34;2nd\u0026#34;:2} // 两个变量指向同一个值, 结果一致 map 遍历 map 使用 range 遍历 map\nmap 值拷贝也需要使用 range 遍历, copy 只适用于切片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 intMap := map[string]int { \u0026#34;1st\u0026#34;: 1, \u0026#34;2nd\u0026#34;: 2, \u0026#34;3rd\u0026#34;: 3, } copyMap := make(map[string]int, 3) for key, value := range intMap { copyMap[key] = value Printf(\u0026#34;%v: %v \\n\u0026#34;, key, value) } \u0026gt; 1st: 1 \u0026gt; 2nd: 2 \u0026gt; 3rd: 3 map 取值 map 使用 [key] 取值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 intMap := map[string]int { \u0026#34;1st\u0026#34;: 1, \u0026#34;2nd\u0026#34;: 2, } value, ok := intMap[\u0026#34;3rd\u0026#34;] // map 取值 if ok == true { // ok 为 true, vaule 为对应 key 的值 Printf(\u0026#34;value: %v\\n\u0026#34;, value) } if ok == false { // ok 为 false, map 不存在 key, value 为类型零值 Printf(\u0026#34;key not in map\u0026#34;) } map 删除 1 2 3 4 5 6 intMap := map[string]int{ \u0026#34;1st\u0026#34;: 1, \u0026#34;2nd\u0026#34;: 2, } delete(intMap, \u0026#34;1st\u0026#34;) ","date":"2023-03-23T19:21:24Z","permalink":"https://facsert.github.io/p/go-map/","title":"Go Map"},{"content":"协程 golang 支持并发和并行, 可以同时跑多个协程 golang 使用 go \u0026lt;function name\u0026gt;() 创建并执行协程 协程本质是一个函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import ( . \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;sync\u0026#34; ) var wg sync.WaitGroup // 定义 wg 辅助协程计数和执行 func main() { Println(time.Now()) // 执行前打印时间 wg.Add(2) // 标记需要执行两个协程 go cook() // 新建协程, 类似于将 cook 放后台执行, main 直接接执行下一行 go wash() // 新建协程, 类似于将 wash 放后台执行, main 直接接执行下一行 wg.Wait() // 等待所有的协程执行完成 Println(time.Now()) // 所有协程执行完后打印时间 } func cook() { time.Sleep(time.Second * 3) // sleep 3s Println(\u0026#34;cook by machine use 3s\u0026#34;) wg.Done() // 标记协程执行完毕 } func wash() { time.Sleep(time.Second * 2) Println(\u0026#34;wash colse by machine use 2s\u0026#34;) wg.Done() } \u0026gt; 2023-04-01 21:51:20.692681383 +0800 CST m=+0.000016384 \u0026gt; wash colse by machine use 2s \u0026gt; cook by machine use 3s \u0026gt; 2023-04-01 21:51:23.693482859 +0800 CST m=+3.000817861 golang 通过新建 2 个协程同时跑 main cook wash 函数, 3 个函数并行执行共花费 3s. main 也是一个协程, main 中若不设置 wg.Wait() 等待其余协程完成, main 执行完成后会关闭所有协程\nchannel 无缓冲通道 通道容量为 0, 不能存值, 发送语句和结束语句需要都执行, 否则一方会一直等待另一方导致阻塞 发送语句先执行, 则发送语句阻塞, 等待接收语句执行 接受语句先执行, 则接受语句阻塞, 等待发送语句执行 以上特性常用于协程同步, 无缓冲通道也被称为同步通道\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import ( . \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;sync\u0026#34; ) var wg sync.WaitGroup func main() { Printf(\u0026#34;start at %v\\n\u0026#34;, time.Now()) ch := make(chan int, 0) // 初始化通道, 设置缓冲容量为 0 wg.Add(1) go receive(ch) // 创建协程 ch \u0026lt;- 3 // 向通道写入数据, 等待接收语句执行, 数据接收后执行下一句 Printf(\u0026#34;send at %v\\n\u0026#34;, time.Now()) } func receive(c chan int) { time.Sleep(time.Second * 2) rec := \u0026lt;- c // 接收通道数据, 若先执行则等待发送语句执行 Printf(\u0026#34;receive %d at %v\\n\u0026#34;, rec, time.Now())// 发送和接收执行同步 wg.Done() } \u0026gt; start at 2023-04-01 22:52:35.842840438 +0800 CST m=+0.000018823 \u0026gt; receive 3 at 2023-04-01 22:52:37.843993741 +0800 CST m=+2.001172157 \u0026gt; send at 2023-04-01 22:52:37.844102485 +0800 CST m=+2.001280900 有缓冲通道 通道容量大于 0, 通道允许在容量未满时存值, 容量存满时变成无缓冲通道\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import ( . \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;sync\u0026#34; ) var wg sync.WaitGroup func main() { Printf(\u0026#34;start at %v\\n\u0026#34;, time.Now()) ch := make(chan int, 2) // 初始化通道, 设置缓冲容量为 2 wg.Add(2) go receive(ch) // 创建协程接收通道的值 go send(ch) // 创建协程向通道传值 wg.Wait() Printf(\u0026#34;over at %v\\n\u0026#34;, time.Now()) } func send(ch chan int) { ch \u0026lt;- 1 ch \u0026lt;- 2 close(ch) // 向通道传值结束后关闭通道 Printf(\u0026#34;send 1,2 at %v\\n\u0026#34;, time.Now()) wg.Done() } func receive(ch chan int) { time.Sleep(time.Second * 1) rec := []int{} for i := range ch { // 通道关闭后, 使用 range 读取通道值 rec = append(rec, i) } Printf(\u0026#34;receive %v at %v\\n\u0026#34;, rec, time.Now())// 发送和接收执行同步 wg.Done() } \u0026gt; start at 2023-04-02 12:20:34.69317803 +0800 CST m=+0.000016435 \u0026gt; send 1,2 at 2023-04-02 12:20:34.693231007 +0800 CST m=+0.000069413 \u0026gt; receive [1 2] at 2023-04-02 12:20:35.693311209 +0800 CST m=+1.000149614 \u0026gt; over at 2023-04-02 12:20:35.693371227 +0800 CST m=+1.000209634 ","date":"2023-03-20T19:23:13Z","permalink":"https://facsert.github.io/p/go-%E5%8D%8F%E7%A8%8B/","title":"Go 协程"},{"content":"read file golang 通过 os 对文件读写 io/ioutil 读写文件调用的是 os 的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import ( . \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;bufio\u0026#34; ) func read(fileName string) string { // 快速读取文件全部内容 content, err := os.ReadFile(fileName) if err != nil { panic(Sprintf(\u0026#34;error: %s\u0026#34;, fileName, err)) } return string(content) } func readLine(fileName string) []string { // 逐行读取文件, 返回字符串切片, 切片元素结尾无换行符号 file, err := os.OpenFile(fileName, os.O_RDONLY, 0666) if err != nil { panic(Sprintf(\u0026#34;error: %v\\n\u0026#34;, err)) } defer file.Close() buf := bufio.NewReader(file) content := []string{} for { line, _, err := buf.ReadLine() if err != nil { break } content = append(content, string(line)) } return content } func readByte(fileName string, length int) string { // 每次读取固定长度字符串 file, err := os.OpenFile(fileName, os.O_RDONLY, 0666) if err != nil { panic(Sprintf(\u0026#34;error: %v\\n\u0026#34;, err)) } defer file.Close() buf := make([]byte, length) content := []byte{} for { _, err := file.Read(buf) if err != nil { break } content = append(content, buf...) } return string(content) } write file 文件写入分两种: 覆盖写入, 追加写入 文件写入函数本质是对 os.OpenFile 的封装\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func Write(fileName, s string) { // 文件覆盖写入, 文件不存在则自动新建 if err := os.WriteFile(fileName, []byte(s), 0666); err != nil { // WriteFile 是对 OpenFile 的封装 panic(Sprintf(\u0026#34;error: %v\\n\u0026#34;, err)) } } func Cover(fileName, s string) { // 覆盖写入文件, 文件不存在则创建 file, err := os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil { panic(Sprintf(\u0026#34;error: %v\\n\u0026#34;, err)) } defer file.Close() if _, err := file.Write([]byte(s)); err != nil { // 也可用 file.WriteString(s), 本质也是调用 file.Write() panic(Sprintf(\u0026#34;error: %v\\n\u0026#34;, err)) } } func Append(fileName, s string) { // 追加写入文件, 文件不存在则创建 file, err := os.OpenFile(fileName, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0666) if err != nil { panic(Sprintf(\u0026#34;error: %v\\n\u0026#34;, err)) } defer file.Close() if _, err := file.Write([]byte(s)); err != nil { panic(Sprintf(\u0026#34;error: %v\\n\u0026#34;, err)) } } OpenFile 模式 model mean O_RDONLY 文件打开模式, 只能选 3 选 1, read only 缩写, 只读 O_WRONLY 文件打开模式, 只能选 3 选 1, write only 缩写, 只写 O_RDWR 文件打开模式, 只能选 3 选 1, read write 缩写, 读写 O_APPEND 文件操作模式, 可多选搭配, append, 追加写入 O_TRUNC 文件操作模式, 可多选搭配, truncate 缩写, 打开文件时清空文件 O_CREATE 文件操作模式, 可多选搭配, create, 文件不存在则创建 O_EXCL 文件操作模式, 可多选搭配, exclusive 缩写, 和 O_CREATE 模式一起使用, 文件必须不存在 ","date":"2023-03-06T19:23:13Z","permalink":"https://facsert.github.io/p/go-%E6%96%87%E4%BB%B6io/","title":"Go 文件IO"},{"content":"Golang 基本类型有\n整形 浮点型 布尔类型 字符串 类型转换 整形 类型 范围 int8 -128 - 127 uint8 / byte 0 - 255 int16 -32768 - 32767 uint16 0 - 65535 int32 / rune -2147483648 ~ 2147483647 uint32 0 ~ 4294967295 int64 -9223372036854775808 ~ 9223372036854775807 uint64 0 ~ 18446744073709551615 int 32 位系统 int32， 64 位系统 int64 uint 32 位系统 uint32， 64 位系统 uint64 整形类型转换 不同整形之间不可以进行运算, 需要转换为同一类型运算\n数字可以与任何整形运算, 运算结果类型不变\n1 2 3 4 5 6 7 8 9 10 11 12 var num8 int8 = 8 var num16 int16 = 16 Printf(\u0026#34;type: %T\\n\u0026#34;, 3) Printf(\u0026#34;num8 add: %d \\n\u0026#34;,num8 + 3) // 数字可直接与 int8 类型数据运算 Println(\u0026#34;num16 add: %d \\n\u0026#34;,num16 + 3) \u0026gt; type: int \u0026gt; num8 add:11 type:int8 // 结果任然为 int8 \u0026gt; num8 add:19 type:int16 Println(\u0026#34;num16 add num8: %d \\n\u0026#34;,num16 + num16) // int8 与 int16 不能直接运算 \u0026gt; ./main.go:42:34: invalid operation: num16 + num8 (mismatched types int16 and int8) 数字类型数据之间可以通过 \u0026lt;type\u0026gt;() 方式进行类型之间的转换\n1 2 3 4 5 6 7 8 var num int = 8 // int num = 8 num8 := int8(num) // int8 num8 = 8 num16 := int16(num) // int16 num16 = 8 num32 := int32(num) // int32 num32 = 8 num64 := int64(num) // int64 num64 = 8 numFloat32 := float32(num) // float32 numFloat32 = 8 numFloat64 := float64(num) // float64 numFloat64 = 8 进制赋值 二进制 八进制 十六进制可以通过前缀赋值 二进制 八进制 十六进制可以通过不同占位符打印\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 binary := 0b11 // int binary = 3 2 进制赋值 octal := 0o11 // int octal = 9 8 进制赋值 hexadecimal := 0x11 // int hexadecimal = 17 16 进制赋值 var ten int = 10 fmt.Printf(\u0026#34;%d \\n\u0026#34;, ten) // 10 fmt.Printf(\u0026#34;%b \\n\u0026#34;, ten) // 1010 占位符%b表示二进制 var eight int = 077 // 八进制 以0开头 fmt.Printf(\u0026#34;%o \\n\u0026#34;, eight) // 77 占位符%o表示八进制 var sixteen int = 0xff // 十六进制 以0x开头 fmt.Printf(\u0026#34;%x \\n\u0026#34;, sixteen) // ff 占位符%x表示十六进制 fmt.Printf(\u0026#34;%X \\n\u0026#34;, sixteen) // FF 占位符%X表示十六进制 类型最大值和最小值 数字类型最大值和最小值, 值在 math 包定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package math intSize = 32 \u0026lt;\u0026lt; (^uint(0) \u0026gt;\u0026gt; 63) // 32 or 64 MaxInt = 1\u0026lt;\u0026lt;(intSize-1) - 1 MinInt = -1 \u0026lt;\u0026lt; (intSize - 1) MaxInt8 = 1\u0026lt;\u0026lt;7 - 1 MinInt8 = -1 \u0026lt;\u0026lt; 7 MaxInt16 = 1\u0026lt;\u0026lt;15 - 1 MinInt16 = -1 \u0026lt;\u0026lt; 15 MaxInt32 = 1\u0026lt;\u0026lt;31 - 1 MinInt32 = -1 \u0026lt;\u0026lt; 31 MaxInt64 = 1\u0026lt;\u0026lt;63 - 1 MinInt64 = -1 \u0026lt;\u0026lt; 63 MaxUint = 1\u0026lt;\u0026lt;intSize - 1 MaxUint8 = 1\u0026lt;\u0026lt;8 - 1 MaxUint16 = 1\u0026lt;\u0026lt;16 - 1 MaxUint32 = 1\u0026lt;\u0026lt;32 - 1 MaxUint64 = 1\u0026lt;\u0026lt;64 - 1 浮点型 浮点型类型: float32 float64\n1 2 3 4 5 var float32 = 2.17 var pi float64 = 3.1415926535 Printf(\u0026#34;e: %f \\n\u0026#34;, e) // e: 2.170000 Printf(\u0026#34;pi: %f \\n\u0026#34;, pi) // pi: 3.141593 布尔类型 布尔值: true false\n布尔值不能进行数字运算\n布尔类型的值默认值是 false\n1 2 3 4 5 6 7 8 9 10 11 yes, no := true, false yes == no // false yes || no // true 逻辑或 yes \u0026amp;\u0026amp; no // false 逻辑且 love, happy := true, false // 布尔运算的哲学 !love // false not love is false love == happy // false love equal to happy is false love != happy // true love not equal to happy is true happy \u0026amp;\u0026amp; love // false love and happy is not true happy || love // true love or happy is true 字符串类型 字符 byte(uint8) ACSII 表中的一个字符, 底层是一个 0-255 数字(数字与 ACSII 表字符绑定)\nrune(int32) Unicode 编码中的一个字符(包含世界大部分语言字符), Unicode 表包含 ACSII 表\n1 2 3 4 5 6 7 8 9 10 11 12 13 var a byte = \u0026#39;D\u0026#39; // \u0026#39;D\u0026#39; 在 ACSII 中第 68 位 var c byte = 68 // ACSII 中 68 为 \u0026#39;D\u0026#39;, 两种赋值等价 var a rune = \u0026#39;中\u0026#39; // \u0026#39;中\u0026#39; 在 Unicode 中第 20013 位 var c rune = 20013 // Unicode 中 20013 为 \u0026#39;中\u0026#39;, 两种赋值等价 Printf(\u0026#34;a equal c: %v\\n\u0026#34;, a == c) \u0026gt; a equal c: true Printf(\u0026#34;acsii length: %d\\n\u0026#34;, len(\u0026#34;str\u0026#34;)) Printf(\u0026#34;unicode length: %d\\n\u0026#34;, len(\u0026#34;中文\u0026#34;)) \u0026gt; acsii length: 3 // 单个 acsii 字符长度为 1 \u0026gt; unicode length: 6 // 单个 unicode 字符长度为 3, 遍历 unicode 不能用索引 字符串 Golang 字符串本质是单个字符的集合, 单个字符的本质是数字, 通过不同规范和字符对应(ACSII 和 Unicode)\n单个 acsii 和 unicode 字符长度不同, 使用 range 遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var acsii, unicode string = \u0026#34;str\u0026#34;, \u0026#34;中文\u0026#34; for index, char := range acsii { Printf(\u0026#34;Type: %T %T, value: %v, value: %c\\n\u0026#34;, char, acsii[index], char, char) } \u0026gt; Type: int32, value: 115, value: s // range 取出的单个字符是 rune 类型 \u0026gt; Type: int32, value: 116, value: t \u0026gt; Type: int32, value: 114, value: r \u0026gt; Type: int32, value: 20013, value: 中 // 使用 range 遍历 unicode 字符串 \u0026gt; Type: int32, value: 25991, value: 文 for i:=0; i\u0026lt;len(unicode); i++ { char := unicode[i] Printf(\u0026#34;Type: %T, value: %v, value: %c\\n\u0026#34;, char, char, char) } \u0026gt; Type: uint8, value: 228, value: ä // 通过 index 索引取出的字符是 byte 类型 \u0026gt; Type: uint8, value: 184, value: ¸ \u0026gt; Type: uint8, value: 173, value: ­ \u0026gt; Type: uint8, value: 230, value: æ \u0026gt; Type: uint8, value: 150, value: \u0026gt; Type: uint8, value: 135, value: 字符串可以与单个字符组成的切片相互转化\n1 2 3 4 5 6 7 8 9 10 11 slice, list := []byte(\u0026#34;str\u0026#34;), []rune(\u0026#34;中文\u0026#34;) fmt.Printf(\u0026#34;Type: %T, value: %v\\n\u0026#34;, slice, slice) \u0026gt; Type: []uint8, value: []byte{0x73, 0x74, 0x72} // 字符串转 byte \u0026gt; Type: []int32, value: []int32{20013, 25991} // 字符串转 rune var strByte byte = \u0026#39;D\u0026#39; var strRune rune = \u0026#39;文\u0026#39; fmt.Printf(\u0026#34;Type: %T, value: %v\\n\u0026#34;, string(strByte), string(strByte)) fmt.Printf(\u0026#34;Type: %T, value: %v\\n\u0026#34;, string(strRune), string(strRune)) \u0026gt; Type: string, value: D // byte 转 string \u0026gt; Type: string, value: 文 // rune 转 string unicode 数值范围内任意数字可以转化为对应的字符\n负数不在 unicode 数值范围内, 负数转化后显示一致, 未能查询到相关解释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var num int = 68 var num8 int8 = 66 var num16 int16 = 66 var num32 int32 = 25991 var num64 int64 = -1 Printf(\u0026#34;Type %T, value: %c\\n\u0026#34;, num16, byte(num16)) Printf(\u0026#34;Type %T, value: %c\\n\u0026#34;, num32, rune(num32)) \u0026gt; Type int, value: D \u0026gt; Type int8, value: B \u0026gt; Type int16, value: B \u0026gt; Type int32, value: 文 \u0026gt; Type int64, value: � 字符串操作 字符串定义后可以查看但不可更改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 str := \u0026#34;learning\u0026#34; fmt.Printf(\u0026#34;Type: %T value: %c base: %v\\n\u0026#34;, str[0], str[1], str[2]) \u0026gt; Type: uint8 value: e base: 97 str[0] = \u0026#34;m\u0026#34; \u0026gt; ./main.go:37:2: cannot assign to str[0] (value of type byte) uStr := \u0026#34;中文\u0026#34; fmt.Printf(\u0026#34;Type: %T value: %v length: %v\\n\u0026#34;, uStr[0], uStr[1], len(uStr)) \u0026gt; Type: uint8 value: 184 length: 6 strRune := []rune(uStr) fmt.Printf(\u0026#34;value: %#v length: %v\\n\u0026#34;, strRune, len([]rune(strRune))) \u0026gt; value: []int32{20013, 25991} length: 2 1 2 3 4 5 6 strings.Split(s, sep) []string // 以 sep 为分隔符, 切割字符串成切片 strings.Contains(s, sub) bool // 判断 s 是否包含 sub strings.Index(s, sub) int // sub 在 s 的序号 strings.Join(slice, sep) string // 通过 sep 把 slice 连接成一个字符串 strings.Replace(s, old, new, count) string // 将 s 中的 old 替换为 new, 替换 count 次 strings.Count(s, sub) int // 返回 sub 在 s 中出现次数 类型转换 任意类型数据都可以转换为字符串\n1 2 3 4 5 6 s := fmt.Sprinf(\u0026#34;%v\u0026#34;, \u0026lt;variable\u0026gt;) // 万能转换, any -\u0026gt; string s := strconv.Itoa(32) // 32 int -\u0026gt; string s := strconv.FormatBool(true) // true bool -\u0026gt; string s := strconv.FormatInt(-8, 2) // -1000 int64 -\u0026gt; string(2 进制) s := strconv.FormatUint(255, 16) // ff uint64 -\u0026gt; string(16 进制) 字符串转其它类型可能会失败, 转数字时还需考虑进制和转换后的类型\n1 2 3 4 5 6 7 8 9 10 11 12 i, err := strconv.Atoi(\u0026#34;-42\u0026#34;) // 42 string -\u0026gt; int b, err := strconv.ParseBool(\u0026#34;true\u0026#34;) // true string -\u0026gt; bool f, err := strconv.ParseFloat(\u0026#34;3.14\u0026#34;, 64) // 3.14 string -\u0026gt; float64 i, err := strconv.ParseInt(\u0026#34;-42\u0026#34;, 10, 64) // -42 string -\u0026gt; int64 u, err := strconv.ParseUint(\u0026#34;42\u0026#34;, 10, 32) // 42 string -\u0026gt; uint32 // ParseFloat (str, bitSize) bitSize:{32:float32, 64:float64} // ParseInt ParseUint (str, base, bitSize) // str string: 待转换的字符串 // base int: str 的进制( base=16, s 为 16 进制的字符串) // bitSize int: {0:int, 8:int8, 16:int16, 32:int32, 64:int64} ","date":"2023-03-06T19:21:13Z","permalink":"https://facsert.github.io/p/go-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","title":"Go 基本类型"},{"content":" 安装 开始 安装 Golang 官网 下载 Golang 最新的包\n解压安装包到 /usr/local 目录下\n1 2 3 4 5 $ wget https://golang.google.cn/dl/go1.20.3.linux-amd64.tar.gz $ tar -zxvf go1.20.3.linux-amd64.tar.gz -C /usr/local/ $ pwd # 压缩包解压到 /usr/local/go 下 \u0026gt; /usr/local/go 将 /usr/local/go/bin 添加进环境目录, 使得系统在环境目录中找到 golang 的可执行文件\n1 2 3 4 5 6 $ vi ~/.bashrc \u0026gt; export GOROOT=/usr/local/go # 将两条命令写入 ~/.bashrc \u0026gt; export PATH=$PATH:$GOROOT/bin # 意为每次启动命令行都将 /usr/local/go/bin 加入环境目录 $ SOURCE ~/.bashrc # 令修改后的 bashrc 生效 $ go env -w GOPROXY=https://goproxy.cn,direct # 更换 go 默认下载源 开始 使用 go mod 创建项目\n1 2 3 4 5 6 7 8 9 10 11 12 $ go mod init \u0026lt;module name\u0026gt; # go mod 初始化项目 $ touch main.go # 创建项目入口 $ ll \u0026gt; total 12K \u0026gt; -rw-r--r-- 1 root root 22 Mar 23 03:24 go.mod \u0026gt; -rw-r--r-- 1 root root 4.2K Apr 25 03:26 main.go $ cat go.mod \u0026gt; module learn \u0026gt; \u0026gt; go 1.20 使用 go mod 创建项目会自动生成 go.mod 文件, 该文件会记录项目需要用的第三方包\n1 2 3 4 5 6 7 8 9 package main // 声明包 import ( // 引入标准库 \u0026#34;fmt\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { // 项目入口, 只允许一个项目入口 fmt.Println(\u0026#34;hello world!\u0026#34;) // 打印 } 执行 main.go\n1 2 $ go run main.go # 执行 go 文件 \u0026gt; hello world! ","date":"2023-03-06T19:21:13Z","permalink":"https://facsert.github.io/p/go-%E7%8E%AF%E5%A2%83/","title":"Go 环境"},{"content":"示例 通过 docker 运行 mongo 数据库\n1 2 3 4 5 6 7 8 9 $ docker pull mongo $ docker images \u0026gt; REPOSITORY TAG IMAGE ID CREATED SIZE \u0026gt; mongo latest 32c5c1d795d9 2 weeks ago 644MB $ docker run -d --restart=always -p 27017:27017 --name mongodb -v /root/Desktop/Mongo:/data/db mongo $ docker ps \u0026gt; CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES \u0026gt; b4da33977293 mongo \u0026#34;docker-entrypoint.s…\u0026#34; 6 seconds ago Up 5 seconds 0.0.0.0:27017-\u0026gt;27017/tcp, :::27017-\u0026gt;27017/tcp mongodb 以 mongo 为镜像, 创建容器 mongodb 容器内 /data/db 目录挂载到系统 /root/Desktop/Mongo 目录下 系统端口 27017 与容器内 27017 端口映射 mongo 容器 1 2 3 4 $ docker exec -it mongodb bash $ mongosh # 进入 mongo shell, 早期版本使用 mongo 命令 \u0026gt; mongo 数据库 集合 文档\n1 2 3 4 5 6 7 test # 数据库名称 student # 集合名称 \u0026lt;id1\u0026gt;: {\u0026#39;_id\u0026#39;: \u0026lt;id1\u0026gt;, \u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;} # 文档，类似行, 一个文档包含一个 json 数据 \u0026lt;id2\u0026gt;: {\u0026#39;_id\u0026#39;: \u0026lt;id2\u0026gt;, \u0026#39;name\u0026#39;: \u0026#39;peter\u0026#39;} teacher # 集合名称 \u0026lt;id1\u0026gt;: {\u0026#39;_id\u0026#39;: \u0026lt;id1\u0026gt;, \u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;} # 文档，类似行, 一个文档包含一个 json 数据 \u0026lt;id2\u0026gt;: {\u0026#39;_id\u0026#39;: \u0026lt;id2\u0026gt;, \u0026#39;name\u0026#39;: \u0026#39;peter\u0026#39;} 数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026gt; show dbs // 显示所有数据库 admin 40.00 KiB config 108.00 KiB local 40.00 KiB test 40.00 KiB \u0026gt; use redis // 创建或切换数据库 switched to db redis \u0026gt; db // 显示当前数据库名称 redis \u0026gt; db.stats() // 数据库 test 的信息 { db: \u0026#39;redis\u0026#39;, collections: 0, views: 0, objects: 0, avgObjSize: 0, dataSize: 0, storageSize: 0, indexes: 0, indexSize: 0, totalSize: 0, scaleFactor: 1, fsUsedSize: 0, fsTotalSize: 0, ok: 1 } \u0026gt; db.dropDatabase() // 删除数据库 redis { ok: 1, dropped: \u0026#39;redis\u0026#39; } 集合 1 2 3 4 5 6 \u0026gt; show collections // 查看数据库内的所有集合 \u0026gt; db.createCollection(\u0026lt;name\u0026gt;, \u0026lt;option\u0026gt;) // 创建集合, 并配置 \u0026gt; db.createCollection(\u0026#34;log\u0026#34;, { capped : true, size : 5242880, max : 5000 } ) \u0026gt; db.log.drop() // 删除 log 集合 option type description capped Boolean true: 集合启用 size 限制, 超过部分自动覆盖最早的条目。启动该选项同时也需指定 size 数值 size number 设定集合最大可使用字节数。capped 为 true 时设置 max number 设置集合能容纳的最大文档数量。Size限制优先于数量限制。文档数量未到 max, size 到达限制时也会触发文档覆盖 文档 1 2 \u0026gt; db.\u0026lt;collection\u0026gt;.insert(\u0026lt;json\u0026gt;) // 指定集合插入 json 数据 \u0026gt; db.\u0026lt;collection\u0026gt;.insert([\u0026lt;json\u0026gt;, \u0026lt;json\u0026gt;]) // 单次插入多个 json 数据, 与多次插入单个 json 一致 ","date":"2023-02-14T15:02:16Z","permalink":"https://facsert.github.io/p/mongo-%E5%9F%BA%E7%A1%80/","title":"Mongo 基础"},{"content":"数组 切片\n数组 数组是确定数量元素的集合, 数组元素类型可以不一致 数组有容量和长度两个属性 cap() len() 查看数组属性 数组的长度和容量始终相等 length == capacity 数组元素可以修改, 但是数组长度和容量声明后就不能修改 数组中未赋值的元素会使用类型的默认值 1 2 3 4 5 6 7 8 9 10 11 strList := [3]string{\u0026#34;hey\u0026#34;, \u0026#34;you\u0026#34;, \u0026#34;world\u0026#34;} // 定义长度为 3 , 元素类型为字符串的数组 strList := [...]string{\u0026#34;hey\u0026#34;, \u0026#34;you\u0026#34;, \u0026#34;world\u0026#34;} // 定义元素为字符串的数组, 根据值推断长度和容量 intList := [3]int{1, 2} // [1 2 0] 定义容量长度均为 3, 类型为 int 的数组 intList := [...]int{1, 2} // [1, 2] 容量和长度均为 2 的 int 数组 intArray := [3]int{1, 4} // [1 4 0] 初始化数组, 未定义的值取 0 intArray[1], intArray[2] = 2, 3 // [1 2 3] 修改数组的值 len(strList) // 3 strList 长度为 3 cap(intList) // 3 intList 容量为 3 any 类型数组 any 类型数组的元素可以是任意类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 var anyList [3]any // [\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt;] any 类型初始值是 nil anyList[0], anyList[1] = \u0026#34;he\u0026#34;, 20000 // [he 2 \u0026lt;nil\u0026gt;] anyList[0] = anyList[0].(string) + \u0026#34; llo\u0026#34; // any 转实际类型操作需要显示声明 anyList[1] = anyList[1].(int) + 1 for index, value := range anyList { fmt.Printf(\u0026#34;index: %v, value: %v type: %T\\n\u0026#34;, index, value, value) } \u0026gt; index: 0, value: hello type: string \u0026gt; index: 1, value: 20000 type: int \u0026gt; index: 2, value: \u0026lt;nil\u0026gt; type: \u0026lt;nil\u0026gt; 数组传递 数组赋值或作为函数参数时, 传递的都是数组的拷贝\n函数若想修改源数组, 传参时需要传入数组地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func three(list [3]int) { // 参数是数组值传递, 外部数组不变 list[0] = 6 } func third(list *[3]int) { // 参数是数组的指针类型, 修改会同步外部数组 list[0] = 9 } source := [...]int{0,1,2} // 定义 source 数组 copy := source // copy 为 source 的拷贝, 互不影响 third(\u0026amp;copy) // 传入 copy 地址, 函数内的修改会同步给外部 copy three(source) // 传入 source 的拷贝, 函数内修改不影响外部 source fmt.Printf(\u0026#34;source: %v copy: %v\\n\u0026#34;, source, copy) \u0026gt; source: [0 1 2] copy: [9 1 2] 切片 切片是一组数量可变的元素集合 切片是引用类型, 切片本身不存储数据, 切片赋值传递的是地址 切片会自动扩容以存储所有添加的数据 切片定义 var 声明切片\nmake 构造切片\n从数组截取切片\n1 2 3 4 5 6 7 8 9 10 11 12 type slice struct { // 切片定义 $GOROOT/go/src/runtime/slice.go array unsafe.Pointer // 指向一个数组中某个元素的指针 (每个切片都对应一个数组) len int // 切片长度 cap int // 切片容量 } var strSlice []string // nil 切片声明, 创建一个 nil 切片, 与 nil 相等 intSlice := []int{} // [] 切片声明并初始化, 创建空切片, 与 nil 不相等 boolSlice := make([]bool, 1, 2) // [false] 初始化布尔切片, 长度为 1, 容量为 2 fmt.Println(strSlice == nil) // true nil 切片与 nil 一致 fmt.Println(intSlice == nil) // false 空切片与 nil 不一致 切片也可以从数组中截取一段\n切片的长度为截取数据的数量, 切片容量为切片开端到数组结尾数量\n1 2 3 4 list := [...]int{0,1,2,3,4} slice := list[1:3] // [1 2] 截取数组创建切片 Printf(\u0026#34;length: %d capacity: %d \\n\u0026#34;, len(slice), cap(slice)) \u0026gt; length: 2 capacity: 4 // 切片长度为截取元素数量, 容量切片开头元素到数组结尾 声明的切片与从数组截取的切片完全一致, 声明的切片对应一个不可见的数组\n切片扩容超过切片容量时, 切片会指向一个更大容量的数组, 并把旧数组的数据复制到新数组\n切片特性 切片是引用类型, 切片不存储数据, 赋值或参数时传递的是地址\n切片扩容超过容量后会生成新的切片\n切片扩容未容量不会生成新的切片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 intSlice := []int{0,0,0,0} // 整数切片初始化, 长度容量均为 4 intArray := intSlice // 切片赋值, 传递的是地址, 两切片指向同一个数组 intArray[0] = 1 // intArray 序号 0 重新赋值, intSlice 跟着变化 intArray = append(intArray, 2) // append 添加元素, 超出容量, 扩容返回新的切片, intArray 变更指向的数组 intArray[1] = 1 // intArray 序号 1 重新赋值 fmt.Printf(\u0026#34;intArray: %v intSlice: %v\\n\u0026#34;, intArray, intSlice) \u0026gt; intArray: [1 1 0 0 2] intSlice: [1 0 0 0] // 切片扩容后, 两切片指定数组不同，值互不影响 slice := make([]int, 3, 5) // 构造长度为 3 容量为 5 的切片 seq := slice // seq slice 指向同一组数据 seq = append(seq, 1) // [0 0 0 1] seq 添加数据, 未超出容量, seq 和 slice 仍指向同一组数据 slice = append(slice, 2) // [0 0 0 2] slice 添加数据, 未超出容量, seq 和 slice 仍指向同一组数据 Printf(\u0026#34;seq: %v slice: %v\\n\u0026#34;, seq, slice) // seq 和 slice 一直指向同一组数据 \u0026gt; seq: [0 0 0 2] slice: [0 0 0 2] // slice 变更覆盖 seq 变更 Golang 1.20 切片的扩容策略 $GOROOT/go/src/runtime/slice.go func growslice\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 newcap := old.cap doublecap := newcap + newcap if cap \u0026gt; doublecap { // 所需容量大于两倍的原有容量 newcap = cap // 扩容后容量等于所需容量 } else { // 所需容量小于两倍原有容量情况下 const threshold = 256 // 设置变更策略的容量阈值 if old.cap \u0026lt; threshold { newcap = doublecap // 原有容量小于 256, 新数组容量为原有两倍 } else { // Check 0 \u0026lt; newcap to detect overflow // and prevent an infinite loop. for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { // 原有容量大于 256, 旧容量自增 192 加 旧容量的四分之一 // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u0026lt;= 0 { newcap = cap } } } Golang 扩容增速从 2 倍逐渐减少至 1.25 倍\n不同类型切片在扩容时候还有特殊的偏移增长机制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 slice := make([]int, 80, 80) for i:=0; i \u0026lt; 2049; i ++ { oldcap := cap(slice) slice = append(slice, 1) newcap := cap(slice) if oldcap != newcap { Printf(\u0026#34;int old: %d new %d \\n\u0026#34;, oldcap, newcap) } } \u0026gt; int old: 80 new 160 \u0026gt; int old: 160 new 336 \u0026gt; int old: 336 new 672 \u0026gt; int old: 672 new 1184 \u0026gt; int old: 1184 new 1696 \u0026gt; int old: 1696 new 2384 \u0026gt; int8 old: 80 new 160 \u0026gt; int8 old: 160 new 320 \u0026gt; int8 old: 320 new 640 \u0026gt; int8 old: 640 new 1024 \u0026gt; int8 old: 1024 new 1536 \u0026gt; int8 old: 1536 new 2304 切片操作 切片使用 append 添加 删除 插入元素\n1 2 3 4 5 6 7 slice := []int{0,0,0,0} slice = append(slice, []int{1, 1}...) // append 添加数据 [0 0 0 0 1 1] slice = append(slice[:1], slice[3:]...) // append 删除数据 [0 0 1 1] slice = append(slice[:1], append([]int{2}, slice[1:]...)...) fmt.Printf(\u0026#34;slice: %v\\n\u0026#34;, slice) \u0026gt; slice: slice: [0 2 0 1 1] // append 插入数据 切片索引 0 \u0026lt;= index \u0026lt; length \u0026lt;= capacity\n截取切片片段 list[low:high]\n切片索引不能为负数\n截取切片时以 list[low:high:max] 设定长度和容量\n1 2 3 4 5 6 7 8 9 10 11 list := [...]int{0,1,2,3} list[3] // 3 切片索引 从左往右 0 开始第 3 个数 list[len(list)-1] // 3 切片索引 最后一个数据 list[:2] // [0 1] 从切片开端到索引 2 截取片段 list[1:] // [1 2 3] 从索引 1 到切片结尾 list[1:3] // [1 2] 切片索引扁片(左闭右开) list[:] // [0 1 2 3] 切片全部数据 list[1:2] // 忽略 high [low:] 容量 3 (length - low) list[1:2:3] // 忽略 high [low:max] 容量 2 (max - low) 1 2 3 4 5 slice := []int{4,1,6,2} fmt.Println(sort.Ints(slice)) // 切片排序 \u0026gt; [1 2 4 6] copy(destSlice, sourceSlice) // 切片复制, dest 容量会影响复制结果 ","date":"2023-02-07T19:22:13Z","permalink":"https://facsert.github.io/p/go-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/","title":"Go 数组和切片"},{"content":"容器列表 1 2 3 4 5 6 7 8 9 10 $ docker ps [OPTIONS] # 显示容器列表及相关信息 $ docker ps $ docker ps -a, --all # 显示所有容器, 包括未运行的 $ docker ps -s, --size # 显示正在运行的容器, 显示容器大小 $ docker ps -q, --quite # 仅显示容器 ID CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES SIZE 7eab1cd126af 43761bd5b76d \u0026#34;docker-entrypoint.s…\u0026#34; 43 hours ago Up 43 hours 27017/tcp person 0B (virtual 700MB) ee0c15a3a0ee mongo \u0026#34;docker-entrypoint.s…\u0026#34; 44 hours ago Up 44 hours 0.0.0.0:8589-\u0026gt;27017/tcp demo 0B (virtual 700MB) CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES SIZE 容器 ID 生成容器的镜像 启动容器时运行的命令 容器创建时间 容器状态 机器端口-\u0026gt;容器端口 容器名称 容器大小 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ docker stop \u0026lt;CONTAINER ID | NAMES\u0026gt; # 关闭容器 $ docker start \u0026lt;CONTAINER ID | NAMES\u0026gt; # 启动容器 $ docker kill \u0026lt;CONTAINER ID | NAMES\u0026gt; # 杀死容器进程 $ docker restart \u0026lt;CONTAINER ID | NAMES\u0026gt; # 重启容器 $ docker rm -f \u0026lt;CONTAINER ID | NAMES\u0026gt; # 强制删除容器(运行中的容器也会删除) $ docker logs \u0026lt;CONTAINER ID | NAMES\u0026gt; # 显示指定容器 log $ docker top \u0026lt;CONTAINER ID | NAMES\u0026gt; # 列出指定容器进程 $ docker port \u0026lt;CONTAINER ID | NAMES\u0026gt; # 显示容器的端口映射 $ docker exec [OPTIONS] CONTAINER COMMAND [ARG...] # 进入容器执行命令(容器在运行状态才可进入) $ docker exec -it mongo-slave1 bash # 以交互式进入 mongo-slave1 容器,执行 bash, 并留在容器中(exit 退出容器) $ docker exec mongo-slave1 mongosh --version # 进入 mongo-slave1 容器查看 mongosh 版本并退出 \u0026gt; 1.6.1 创建容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Options: -d, --detach # 后台运行容器，并输出容器ID -e, --env list # 设置环境变量，该变量可以在容器内使用 -h, --hostname string # 指定容器的hostname -i, --interactive # 以交互模式运行容器，通常与-t同时使用 -l, --label list # 给容器添加标签 --name \u0026lt;name\u0026gt; # 设置容器名称，否则会自动命名 --network string # 将容器加入指定网络 -p, --publish list # 设置容器映射端口 \u0026lt;server port\u0026gt;:\u0026lt;docker port\u0026gt; -P,--publish-all # 将容器设置的所有exposed端口进行随机映射 --restart \u0026lt;restart option\u0026gt; # 容器重启策略，默认为不重启 on-failure[:max-retries]： # 在容器非正常退出时重启，可以设置重启次数。 unless-stopped： # 总是重启，除非使用stop停止容器 always： # 总是重启 --rm # 容器退出时则自动删除容器 -t, --tty # 分配一个伪终端 -u, --user \u0026lt;username\u0026gt; # 运行用户或者UID -v, --volume list # 容器目录映射到主机目录 \u0026lt;server path\u0026gt;:\u0026lt;docker path\u0026gt; -w, --workdir \u0026lt;work path\u0026gt; # 容器的工作目录 --privileged # 给容器特权 1 2 3 4 5 6 7 $ docker run -it --rm ubuntu bash # 以 ubuntu 镜像创建容器(自动命名), 创建后执行 bash, 退出后自动删除容器 $ docker run -itd -p 8589:27017 --name demo mongo # 以 mongo 镜像创建 demo 容器, 后台运行, 机器 8589 端口映射到容器 27017 端口 $ docker run -it --rm -v /root/docker:/root debian bash # debian 镜像创建容器, 容器 /root 目录映射到主机 /root/docker 目录 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ee0c15a3a0ee mongo \u0026#34;docker-entrypoint.s…\u0026#34; 13 seconds ago Up 11 seconds 0.0.0.0:8589-\u0026gt;27017/tcp demo ","date":"2022-12-23T20:37:13Z","permalink":"https://facsert.github.io/p/docker-%E5%AE%B9%E5%99%A8/","title":"Docker 容器"},{"content":"介绍 镜像是容器的模板, 所有容器都通过镜像创建的\n一个镜像可以生成任意数量的容器\n可以使用官方镜像或者自定义镜像\n镜像列表 1 2 3 4 5 6 7 8 9 10 11 12 13 $ docker images [OPTIONS] [REPOSITORY[:TAG]] Options: -a, --all Show all images (default hides intermediate images) --digests Show digests -f, --filter filter Filter output based on conditions provided --format string Pretty-print images using a Go template --no-trunc Do not truncate output -q, --quiet Only show numeric IDs $ docker images \u0026gt; REPOSITORY TAG IMAGE ID CREATED SIZE \u0026gt; mongo latest 0850fead9327 12 days ago 700MB \u0026gt; pipreqs 1.0 d4633ae3a8af 2 months ago 1.08GB REPOSITORY TAG IMAGE ID CREATED SIZE 镜像仓库源 镜像 tag 镜像 ID 镜像创建时间 镜像大小 拉取镜像 官方镜像 私有镜像 拉取镜像前可以使用 docker search 查看官方及第三方镜像列表\n未指定链接默认从官方镜像拉取\n1 2 3 4 5 6 $ docker pull [OPTIONS] NAME[:TAG|@DIGEST] Options: -a, --all-tags Download all tagged images in the repository --disable-content-trust Skip image verification (default true) $ docker pull ubuntu:20.04 从私有仓库拉取镜像前需要先登录, 然后指定仓库中的镜像拉取\n在私有仓库中未找到镜像会到官方镜像仓库拉取\n1 2 3 4 5 6 7 $ docker login [person registry] \u0026gt; docker login registry.facser:8081 Username (facser): facser Password: Login Succeeded $ docker pull registry.facser:8081/ubuntu:20.04 删除镜像 1 2 3 4 5 6 7 8 9 10 11 $ docker rmi [OPTIONS] IMAGE [IMAGE...] Options: -f, --force Force removal of the image --no-prune Do not delete untagged parents $ docker images \u0026gt; REPOSITORY TAG IMAGE ID CREATED SIZE \u0026gt; mongo latest 0850fead9327 12 days ago 700MB \u0026gt; pipreqs 1.0 d4633ae3a8af 2 months ago 1.08GB $ docker rmi 0850fead9327 其它操作 查找镜像 1 2 3 4 5 6 $ docker search [OPTIONS] [IMAGE NAME] $ docker search ubuntu \u0026gt; NAME DESCRIPTION STARS OFFICIAL AUTOMATED \u0026gt; ubuntu Ubuntu is a Debian-based Linux operating sys… 15368 [OK] \u0026gt; websphere-liberty WebSphere Liberty multi-architecture images … 290 [OK] NAME DESCRIPTION STARS OFFICIAL AUTOMATED 镜像名称 镜像名称 点赞数 是否官方 是否自动构建 保存镜像 1 2 3 4 5 $ docker save [OPTIONS] IMAGE [IMAGE...] $ docker save 0850fead9327 \u0026gt; mongo.tar.gz $ ll \u0026gt; -rw-r--r-- 1 root root 23K Mar 7 21:10 mongo.tar.gz 镜像历史 1 2 3 4 5 $ docker history [OPTIONS] IMAGE $ docker history 0850fead9327 \u0026gt; IMAGE CREATED CREATED BY SIZE COMMENT \u0026gt; 0850fead9327 12 days ago /bin/sh -c #(nop) CMD [\u0026#34;mongod\u0026#34;] 0B 修改镜像 tag 1 2 3 4 5 6 7 8 9 10 11 12 13 $ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mongo-base v1 43761bd5b76d 41 hours ago 00MB mongo-base v2 43761bd5b76d 41 hours ago 700MB $ docker tag mongo-base:v2 mongo-person:1.0.0 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mongo-base v1 43761bd5b76d 41 hours ago 700MB mongo-person 1.0.0 43761bd5b76d 41 hours ago 700MB 自定义镜像 docker build 1 2 3 4 5 6 7 8 9 10 11 12 docker build [OPTIONS] PATH | URL | - Options: --file, -f # 指定要使用的Dockerfile路径； --tag, -t # 镜像的名字及标签(name:tag 或 name, 允许多个) --no-cache # 不使用缓存 $ docker build -t nginx-base:v1 . # \u0026#34;.\u0026#34; 查找当前目录下的 Dockerfile 构建镜像 $ docker build -t nginx-base:v1 -f /root/Dockerfile # 指定 Dockerfile 构建镜像 REPOSITORY TAG IMAGE ID CREATED SIZE nginx-base v1 43761bd5b76d 41 hours ago 700MB Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 FROM ubuntu # 以 ubuntu 镜像为基础, 可添加 tag, ubuntu:20.04 ENV path=/usr/local/ # 设置全局变量, 可添加多个，或 ENV 多次设置, 可以使用已设置的变量 ARG USERNAME=\u0026#34;facser\u0026#34; # 设置 build 执行参数, 通过 --build-arg \u0026lt;key\u0026gt;=value 来修改 LABEL version=\u0026#34;1.0.0\u0026#34; description=\u0026#34;ubuntu image by $USERNAME\u0026#34; # 添加镜像元数据 ADD nginx-1.8.0.tar.gz $path # 将系统下文件复制到镜像中目录下 ADD epel-release-latest-7.noarch.rpm $path WORKDIR $path # 设定镜像中工作目录, 并转到改目录, 类似 cd 命令, 可以多次设置 RUN rpm -ivh /usr/local/epel-release-latest-7.noarch.rpm \u0026amp;\u0026amp;\\ # 执行 shell 命令 yum install -y wget lftp gcc gcc-c++ make openssl-devel pcre-devel pcre \u0026amp;\u0026amp;\\ yum clean all \u0026amp;\u0026amp;\\ cd $path/nginx-1.8.0 \u0026amp;\u0026amp;\\ ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-pcre \u0026amp;\u0026amp;\\ make \u0026amp;\u0026amp;\\ make install \u0026amp;\u0026amp;\\ echo \u0026#34;daemon off;\u0026#34; \u0026gt;\u0026gt; /etc/nginx.conf CMD /usr/sbin/nginx # 生成容器后执行的命令, 会被 docker run 生成容器时初始命令覆盖 1 2 3 4 FROM IMAGE[:TAG] # 第一行必须是 FROM, 选择基础镜像, 可以设置多个 FROM ubuntu:20.04 FROM centos 1 2 3 4 5 6 7 8 ARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;] # 设置构建镜像的外部参数, 修改参数需要使用 --build-arg ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; # 设置 Dockerfile 内全局变量 ARG USERNAME=\u0026#34;facser\u0026#34; # Dockerfile 设置默认参数 \u0026#34;facser\u0026#34; $ docker build --build-arg USERNAME=\u0026#34;kertory\u0026#34; -t demo:v1 # build 镜像时通过 --build-arg 修改 USERNAME 的值 ENV FILENAME \u0026#34;record.log\u0026#34; # 设置 Dockerfile 内全局变量, 一般全大写, 用法与 shell 一致 ENV TITLE=\u0026#34;title in $FILENAME\u0026#34; # \u0026#34;title in record.log\u0026#34;, 使用 = 可以设置多个变量 1 2 3 4 5 COPY \u0026lt;src\u0026gt; \u0026lt;dest\u0026gt; ADD \u0026lt;src\u0026gt; \u0026lt;dest\u0026gt; COPY client.log /root/docker.log # 将容器外的文件复制到镜像指定目录下 ADD /root/client.log /root/docker.log # 使用绝对路径, 效果一致 1 2 3 4 5 6 WORKDIR \u0026lt;path\u0026gt; # 设置镜像内的工作目录, 类似 cd 效果 WORKDIR /root # 进入 /root 并设为工作目录 WORKDIR /home # 将工作目录转到 /home WORKDIR facser # 将工作目录转到 /home/facser WORKDIR Desktop # 将工作目录转到 /home/facser/Desktop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 RUN \u0026lt;command\u0026gt; # 通过 sh 执行命令 RUN [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] # 指定 shell 执行命令 RUN date # 通过 sh 执行 date 命令 (命令执行失败即停止) RUN [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;date\u0026#34;] # 和上命令完全一致 RUN [\u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;date\u0026#34;] # 通过 bash 执行 date 命令 (命令执行失败继续执行) RUN echo \u0026#34;line first\u0026#34; \u0026gt;\u0026gt; /root/run.log # 执行 3 个 RUN 指令, 创建 3 个镜像层 RUN echo \u0026#34;line second\u0026#34; \u0026gt;\u0026gt; /root/run.log # 层数越多占用空间更大 RUN echo \u0026#34;line third\u0026#34; \u0026gt;\u0026gt; /root/run.log # 创建失败时, 从失败的上一层 RUN 继续, 重新创建速度更快 RUN echo \u0026#34;line first\u0026#34; \u0026gt;\u0026gt; /root/run.log \u0026amp;\u0026amp;\\ # 一个 RUN 指令创建 1 个镜像层 echo \u0026#34;line second\u0026#34; \u0026gt;\u0026gt; /root/run.log \u0026amp;\u0026amp;\\ # 只有一层镜像, 占用更小 echo \u0026#34;line third\u0026#34; \u0026gt;\u0026gt; /root/run.log # 每次创建都需要从头开始执行 1 2 3 4 5 6 CMD \u0026lt;command\u0026gt; # 以次文件构建的镜像, 创建容器后, 通过 sh 执行命令 CMD [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] # 以次文件构建的镜像, 创建容器后, 指定 shell 执行命令 CMD /bin/bash # 会被 docker run 创建容器时指定的命令覆盖 $ docker run -it --name nginx-demo nginx-base echo \u0026#34;create mongo container\u0026#34; # echo 命令覆盖 /bin/bash 指令 注: 创建容器时, 若执行的命令在一定时间内能完成, 则容器在执行完命令就会关闭\necho \u0026ldquo;hello docker\u0026rdquo;, 创建容器在执行完 echo 命令后便关闭改容器 /bin/bash, 该命令未收到 exit 退出前会一直执行, 该容器会保持运行状态 ","date":"2022-12-23T19:35:13Z","permalink":"https://facsert.github.io/p/docker-%E9%95%9C%E5%83%8F/","title":"Docker 镜像"},{"content":"介绍 ","date":"2022-12-23T19:31:13Z","permalink":"https://facsert.github.io/p/docker-%E7%BD%91%E7%BB%9C/","title":"Docker 网络"},{"content":"介绍 ansible 是一个基于 python 实现的自动化运维工具, 实现对多个系统进行批量化操作.\n环境 安装\n1 $ apt install ansible 配置节点 编辑 /etc/ansible/hosts 添加群组或节点\n1 2 3 4 5 [manager] localhost [node] 172.17.0.10 命令 1 2 3 4 5 6 7 8 $ ansible $ ansible-doc $ ansible-playbook $ ansible-vault $ ansible-console $ ansible \u0026lt;host pattern\u0026gt; -m \u0026lt;module\u0026gt; -a \u0026lt;args\u0026gt; $ ansilbe all -m shell -a \u0026#34;ifconfig\u0026#34; 查询 1 2 3 $ ansible --version $ ansible all --list-host $ 执行命令 1 2 $ ansible \u0026lt;host pattern\u0026gt; -m command -a \u0026lt;command\u0026gt; $ ansible \u0026lt;host pattern\u0026gt; -m shell -a \u0026lt;shell command\u0026gt; 文件 1 2 $ ansible node -m copy -a \u0026#34;src=/root/local dst=/root/remote\u0026#34; $ ansible node -m fetch -a \u0026#34;src=/root/remote dst=/root/local\u0026#34; Playbook ","date":"2022-11-08T16:03:37Z","permalink":"https://facsert.github.io/p/ansible/","title":"Ansible"},{"content":"介绍 Hexo 官网\nMarkdown 文件 \u0026ndash;\u0026gt; Hexo 静态网页 \u0026ndash;\u0026gt; Github Page 页面\nHexo 是一个基于 JS 的博客框架, Hexo 可以解析 Markdown 生成静态网页 Github Page 为账户下的仓库提供免费的域名, 显示仓库的静态网页\n准备 工具 使用 Github 注册账户, 并添加 sshkey node node 的包管理工具 npm 安装 Hexo 及主题 Git 本地代码上传到 github 的工具 VS Code 编辑 Hexo 配置或markdown文件 Github 仓库 注册 github 账号, 设置 sshkey (浅谈 Git 中有介绍) 创建仓库, 仓库名固定为 \u0026lt;user\u0026gt;.github.io 如 facser.github.io (user 指账户名) 1 $ https://\u0026lt;user\u0026gt;.github.io/ # 使用该 url 确认是否创建成功 Hexo 安装 创建文件夹用于保存 Hexo 文件(如在 D 盘创建 blog 文件夹)\n安装 Vscode 编辑器, git 工具, node 使用 Vscode 打开 blog 文件夹, 命令行输入(快捷键: ctrl + ~)\n1 2 3 4 5 $ git --version # 查看 git 版本, 检查 git 是否安装成功 \u0026gt; git version 2.27.0.windows.1 $ npm -v # 查看 npm 版本, 检查 node 是否安装成功 \u0026gt; 6.14.6 安装 hexo\n1 2 $ npm install -g hexo-cli # 下载安装 hexo 所有的包 $ npm i hexo-deployer-git # 下载安装 hexo 的 git 专用包 注: 若无法下载 hexo 或速度较慢可修改 npm 源为国内镜像, 命令如下:\nnpm config set registry https://registry.npm.taobao.org/\nHexo 本地 vscode 打开 blog 文件夹\n1 2 3 $ hexo init # 生成初始化文件 $ hexo g # 生成静态网页 $ hexo s # 部署静态网页到本地预览 注: INFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop. 将 http://localhost:4000/ 复制到浏览器打开即可预览\n此时本地 blog 还未绑定 github 域名, 用的也是初始主题\n网站配置 Hexo 网站参数\n在目录下的 _config.yml 中配置网站信息\n参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 简中使用 zh-CN timezone 网站时区 1 2 3 4 5 6 7 title: facser subtitle: \u0026#39;\u0026#39; description: \u0026#39;facser blog\u0026#39; keywords: author: facser language: zh-CN timezone: \u0026#39;\u0026#39; 注: 不填的选项, Hexo 会使用默认值\nHexo 绑定 github hexo 绑定私有 repo\n编辑 blog 目录下 _config.yml 文件\n1 2 3 4 5 deploy: type: git repo: git@github.com:facser/facser.http-github.io.git # 仓库 url branch: master # 代码分支 message: modify git.md another time # commit 内容 Hexo 主题 hexo 主题库\n选择一款主题下载到本地, 将主题文件夹, 放入目录下的 themes 文件夹中 编辑 _config.yml, 找到 theme 选项, 替换为下载的主题文件夹名\n1 theme: \u0026lt;theme\u0026gt; # themes 文件夹下的主题 编辑文章 Hexo 创建文章 Hexo 添加属性\nVscode 打开 blog 文件夹, 命令行输入:\n1 $ hexo new post \u0026lt;title\u0026gt; # 创建文章, title 表示文章标题 Hexo 会在 source/_posts 创建 \u0026lt;title\u0026gt;.md 文件\n文件生成后, 头部会带有 title 及 data 信息, 自行选择添加属性\n参数 描述 title 文章大标题 date 文章创建时间 tags 文章标签 categories 文章分类 excerpt 文章摘要 1 2 3 4 5 6 7 8 9 10 --- title: 浅谈 Git date: 2022-07-10 21:08:54 categories: - [tools] - [share] tags: - git excerpt: git 配置及使用 --- Hexo 上传 1 2 3 $ hexo clean # 清除原有的静态网页 $ hexo g # generate 生成静态网页 $ hexo d # 上传网页到 github 仓库 注: 可使用 hexo s 命令进行本地预览\n","date":"2022-11-08T16:03:37Z","permalink":"https://facsert.github.io/p/hexo/","title":"Hexo"},{"content":" 模块化 分离工具代码 少写代码 模块化 分离相关性不大的代码, 一个模块做一件事\n模块化使得代码易于测试和扩展\n少写代码 不要重复造轮子, 复用已有实现\n1 2 3 4 5 6 7 8 9 10 11 12 def unique_list(array): pass def sort_list_one(): pass def sort_list_two(): pass unique_list = list(set(raw_list)) # 使用集合的特性消除重复数据(集合每个元素唯一) sort_list = sorted(raw_list) # 使用库函数排序 分离工具代码 抽离与系统无关的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def compare_list_average(list_a, list_b): a_sum, a_length = 0, len(list_a) for i in list_a: a_sum += i a_average = a_sum / a_length b_sum, b_length = 0, len(list_b) for i in list_b: b_sum += i b_average = b_sum / b_length return a_average \u0026gt; b_average def average(array): array_sum, array_length = 0, len(array) for i in array: array_sum += i return array_sum / array_length def compare_list_average(list_a, list_b): a_average = average(list_a) b_average = average(list_b) return a_average \u0026gt; a_average 拓展 函数式编程 简单说，\u0026ldquo;函数式编程\u0026quot;是一种\u0026quot;编程范式\u0026rdquo;（programming paradigm），也就是如何编写程序的方法论 它属于\u0026quot;结构化编程\u0026quot;的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用\n只用表达式不用语句 每一步都是计算, 都有返回值\n无副作用, 不改变外部变量 不改变外部变量或状态\n纯函数, 参数与返回值一一对应 相同输入输出必定相同\nSOLID 原则 SOLID 是面向对象编程应当遵守的准则和最佳的实践方向\nSRP 单一职责 Single Responsibility Principle There should never be more than one reason for a class to change\nOCP 开闭原则 原始定义:\nOpen Closed Principle\nLSP 里式替换原则 Liskov Substitution Principle\nISP 接口替换原则 Interface Segregation Principle\nDIP 依赖倒置原则 Dependency Inversion Principle\n","date":"2022-11-04T21:27:49Z","permalink":"https://facsert.github.io/p/%E7%BB%84%E7%BB%87%E8%AE%BE%E8%AE%A1/","title":"组织设计"},{"content":" 分支 边界 变量的逻辑 分支 最小化嵌套 正向优先 最小化嵌套 提前退出 优先解决简单问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 if sut_os_connect(): if sut_tool_exist(): if sut_bmc_version(): # flash BMC else: return \u0026#39;get BMC version failed\u0026#39; else: return \u0026#39;tool not exist\u0026#39; else: return \u0026#39;sut os connect failed\u0026#39; if not sut_os_connect(): # if sut_os_connect_fail return \u0026#39;sut os connect failed\u0026#39; if not sut_tool_exist(): # if sut_tool_not_exist return \u0026#39;tool not exist\u0026#39; if not sut_bmc_version(): # if sut_bmc_version_fail return \u0026#39;get BMC version failed\u0026#39; # flash BMC 正向优先 正向结果优先\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 if is_pass: # case PASS ... else: # case FAIL ... if not is_pass: # case FAIL ... else: # case PASS ... if is_fail: # case FAIL ... else: # case PASS ... 分支参数, 左边为变量, 右边为常量\n1 2 3 4 5 if num \u0026gt; 5: pass if 5 \u0026gt; num: pass 边界 简化边界问题, 忽略或合并不关注的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if type(bkm) == int: if type(bkms) == list: if bkm in bkms: return bkms.index(bkm) else: return f\u0026#39;{bkm} not in {bkms}\u0026#39; else: return f\u0026#39;{bkms} not a list\u0026#39; else: return f\u0026#39;{bkm} type not int\u0026#39; try: return bkms.index(bkm) except Exception as e: return f\u0026#39;Get {bkm} index error\u0026#39; 变量的逻辑 少创建无效变量 减小变量作用域 少创建无效变量 变量越多负担越重 消除无效的中间变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 note = \u0026#39;Continue the test when error occurred? (default: Y N/Y)\u0026#39; input_raw = input(note) input_no_space = input_raw.strip() input_up = input_no_space.upper() input_ok = input_up in (\u0026#39;Y\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;\u0026#39;) if input_up in (\u0026#39;Y\u0026#39;, \u0026#39;\u0026#39;): print(\u0026#39;continue test when error occurred\u0026#39;) else: print(\u0026#39;stop test when error occurred\u0026#39;) note = \u0026#39;Continue the test when error occurred? (default: Y N/Y)\u0026#39; if input(note).strip().upper() in (\u0026#39;\u0026#39;, \u0026#39;Y\u0026#39;): print(\u0026#39;continue test when error occurred\u0026#39;) else: print(\u0026#39;stop test when error occurred\u0026#39;) 1 2 3 4 5 6 bmc_cmd = \u0026#39;systemctl status docker\u0026#39; cmd_ret = subprocess.Popen(bmc_cmd) print(bmc_cmd) print(cmd_ret) run(\u0026#39;systemctl status docker\u0026#39;) 减小变量作用域 缩减变量作用域以减轻变量的追踪难度\n减小变量的使用跨度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 username = \u0026#39;admin\u0026#39; password = \u0026#39;admin\u0026#39; config = {} config_valid = {} tool_dir = \u0026#39;tools\u0026#39; log_dir = \u0026#39;reports/process.log\u0026#39; count = 0 key = None value = None # read config config = {} config_valid = {} # set output file log_dir = \u0026#39;reports/process.log\u0026#39; # test step username = \u0026#39;admin\u0026#39; password = \u0026#39;admin\u0026#39; tool_dir = \u0026#39;tools\u0026#39; count = 0 ","date":"2022-11-03T21:27:49Z","permalink":"https://facsert.github.io/p/%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91/","title":"代码逻辑"},{"content":"代码可读性 最小化理解代码的时间 平衡开发时间和易读性\n改进代码文字 简化代码控制流 组织代码功能 改进代码文字 风格 紧凑简洁, 段落清晰, 风格一致\n命名 简洁而准确的命名\n注释 言简意赅的注释\n简化代码控制流 分支 避免分支嵌套, 提前退出 优先正向分支\n边界 全面思考边界的可能性 聚焦重心, 忽略或合并不关注的内容\n变量的逻辑 少创建无效变量 减小变量作用域\n组织代码功能 模块化 根据项目规模保持模块的粒度\n少写代码 开发时不要重复造轮子\n分离工具代码 抽离与系统无关的代码\n","date":"2022-11-01T21:27:49Z","permalink":"https://facsert.github.io/p/%E6%A6%82%E8%BF%B0/","title":"概述"},{"content":"类型约束 1 2 3 4 5 6 7 8 func detail[T string| int| bool](item T) { // 多类型参数定义 fmt.Printf(\u0026#34;value: %v \\n\u0026#34;, variable) // 打印变量的值 fmt.Printf(\u0026#34;type: %T\u0026#34;, variable) // 打印变量的类型 } func add[T string| int](a T, b T) { // 多类型参数定义, a b 类型相同, 且都为 string 或 int fmt.Println(a + b) // 打印结果 } ","date":"2022-10-20T19:25:13Z","permalink":"https://facsert.github.io/p/go-%E6%B3%9B%E5%9E%8B/","title":"Go 泛型"},{"content":"引申 举办一个活动, 参加的人必须是能唱歌和玩游戏, 所以不管男女老幼, 只要能唱歌和玩游戏就应该都能参加 对于这个活动, 强调的是能唱歌能玩游戏这两种行为, 不关心其余特质和行为\n用 Go 实现的效果\n1 2 3 4 5 6 7 8 type People struct { name string } // 定义 People 结构体 func (p people) sing() { ... } // 定义结构体方法 sing func (p people) play() { ... } // 定义结构体方法 play func activate(singer s, player p) { // 定义函数, 参数为 singer 和 player 类型 s.sing() p.play() } 然而实际上 People 类型不能作为 activate 的参数 People 即使具有 singer 类型和 player 类型的行为, 但由于类型限制, 无法使用\n为了解决以上问题产生了接口类型这一概念\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type singer interface { sing() } // 定义 singer 接口类型, 只要实现 sing() 即可作为 singer 类型使用 type player interface { play() } // 定义 player 接口类型, 只要实现 play() 即可作为 player 类型使用 type People struct { name string } // 定义 People 结构体 func (p people) sing() { ... } // 定义结构体方法 sing func (p people) play() { ... } // 定义结构体方法 play func activate(singer s, player p) { // 定义函数, 参数为 singer 和 player 类型 s.sing() p.play() } human := People{ name: \u0026#34;facser\u0026#34; } // 实例化 People, People 实现了 sing() play() activate(human, human) // 第一个 human 作为 singer 类型，第二个 human 作为 player 类型 接口类型是一个自定义的抽象类型 接口用于定义拥有同样行为的类型 任意其它类型只要包含接口定义的方法， 都可以作为接口类型使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 type \u0026lt;interface name\u0026gt; interface { \u0026lt;function name\u0026gt;(\u0026lt;parameter name\u0026gt; \u0026lt;parameter type\u0026gt;) \u0026lt;return type\u0026gt; } type app interface { // 定义一个 app 类型接口 open(click int) string // 定义 app 类型需要满足的条件 close(action string) string // 任意结构体实现了接口定义的方法就可以作为 app 类型使用 } type browser struct ( // 定义 browser 类型结构体 name string // 定义 browser 结构体属性 ) func (b browser) open(click int) string { // browser 类型结构体实现 open 方法 return Sprintf(\u0026#34;click %d open %s\u0026#34;, click, b.name) } func (b browser) close(action string) string { // browser 类型结构体实现 close 方法 return Sprintf(\u0026#34;use %s close %s\u0026#34;, action, b.name) } func relax(application app) { // 定义函数 relax, 函数参数为 app 接口类型 Println(application.open(2)) // 执行 read 方法 Println(application.close(\u0026#34;swipe up\u0026#34;)) // 执行 search 方法 } chrome := browser{name: \u0026#34;chrome browser\u0026#34;} // 实例化 chrome, chrome 包含 open close 方法 relax(chrome) // chrome 满足接口条件, chrome 可以当做 app 类型使用 \u0026gt; click 2 open chrome browser \u0026gt; use swipe up close chrome browser ","date":"2022-10-20T19:23:13Z","permalink":"https://facsert.github.io/p/go-%E6%8E%A5%E5%8F%A3/","title":"Go 接口"},{"content":"安装 Docker 安装\n下载官方一键安装脚本安装\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ curl -fsSL https://get.docker.com -o get-docker.sh # 下载官方一键安装脚本 $ sudo sh get-docker.sh # 执行安装脚本 $ docker --version # 检查 docker 安装版本 \u0026gt; Docker version 24.0.5, build ced0996 $ sudo apt-get purge docker-ce \\ # 卸载 docker docker-ce-cli \\ containerd.io \\ docker-buildx-plugin \\ docker-compose-plugin \\ docker-ce-rootless-extras $ sudo rm -rf /var/lib/docker # 删除 docker 相关文件 $ sudo rm -rf /var/lib/containerd 配置 编辑 /etc/docker/daemon.json(不存在则创建一个), 选择需要修改的配置写入文件\n官方参数说明\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;insecure-registries\u0026#34;: [\u0026#34;192.168.2.2:8080\u0026#34;], # 私有镜像仓库, 第三方镜像源 \u0026#34;\u0026lt;IP\u0026gt;:\u0026lt;PORT\u0026gt;\u0026#34; \u0026#34;dns\u0026#34;: [], # 设定容器DNS的地址，在容器的 /etc/resolv.conf文件中可查看 \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], # 运行时执行选项 \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://ucjisdvf.mirror.aliyuncs.com\u0026#34;], # 更换官方镜像仓库地址为国内镜像地址 \u0026#34;log-level\u0026#34;: \u0026#34;info\u0026#34;, # 显示日志等级 (debug|info|warn|error|fatal, 默认为 info) \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, # log 驱动 \u0026#34;log-opts\u0026#34;: { # 容器默认日志驱动程序选项 \u0026#34;max-size\u0026#34;: \u0026#34;100m\u0026#34;, \u0026#34;max-file\u0026#34;: \u0026#34;3\u0026#34; }, \u0026#34;data-root\u0026#34;: \u0026#34;/var/lib/docker\u0026#34; # docker 运行及日志保存位置 (默认 /var/lib/docker) } 更换 Docker 镜像源\n1 2 3 4 5 6 7 8 9 { \u0026#34;registry-mirrors\u0026#34; : [ \u0026#34;https://registry.docker-cn.com\u0026#34;, \u0026#34;http://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://cr.console.aliyun.com\u0026#34;, \u0026#34;https://mirror.ccs.tencentyun.com\u0026#34; ] } 修改配置文件后需要重启 docker 服务生效\n1 2 3 4 5 6 7 8 9 $ systemctl daemon-reload # 重新加载 docker 配置文件 $ systemctl restart docker # 重新启动 docker $ systemctl status docker \u0026gt; ... \u0026gt; Activate: activate(running) \u0026gt; ... $ $ systemctl enable docker # 设置为开机启动 Docker 基本参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 $ docker --help 管理命令: container 管理容器 image 管理镜像 network 管理网络 命令： attach 介入到一个正在运行的容器 build 根据 Dockerfile 构建一个镜像 commit 根据容器的更改创建一个新的镜像 cp 在本地文件系统与容器中复制 文件/文件夹 create 创建一个新容器 exec 在容器中执行一条命令 images 列出镜像 kill 杀死一个或多个正在运行的容器 logs 取得容器的日志 pause 暂停一个或多个容器的所有进程 ps 列出所有容器 pull 拉取一个镜像或仓库到 registry push 推送一个镜像或仓库到 registry rename 重命名一个容器 restart 重新启动一个或多个容器 rm 删除一个或多个容器 rmi 删除一个或多个镜像 run 在一个新的容器中执行一条命令 search 在 Docker Hub 中搜索镜像 start 启动一个或多个已经停止运行的容器 stats 显示一个容器的实时资源占用 stop 停止一个或多个正在运行的容器 tag 为镜像创建一个新的标签 top 显示一个容器内的所有进程 unpause 恢复一个或多个容器内所有被暂停的进程 ","date":"2022-10-10T19:31:13Z","permalink":"https://facsert.github.io/p/docker-%E5%9F%BA%E7%A1%80/","title":"Docker 基础"},{"content":"指针 变量 指针变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 strVar := \u0026#34;initial\u0026#34; // 初始化变量赋值, 绑定一个固定地址, 值可以变, 地址不变 Printf(\u0026#34;initial strVar value:%v, addr: %p\\n\u0026#34;, strVar, \u0026amp;strVar) straddr := \u0026amp;strVar // 初始化地址类型变量并赋值, 变量绑定地址, 变量值是一个地址 Printf(\u0026#34;initial straddr value: %v, addr: %p\\n\u0026#34;, straddr, \u0026amp;straddr) addrVal := *straddr // 初始化并赋值, 变量绑定地址, 地址类型才能取值 Printf(\u0026#34;initial strVar value:%v, addr: %p\\n\u0026#34;, addrVal, \u0026amp;addrVal) strVar = \u0026#34;modify\u0026#34; Printf(\u0026#34;modify strVar value:%v, addr: %p\\n\u0026#34;, strVar, \u0026amp;strVar) Printf(\u0026#34;modify straddr value: %v, addr: %p\\n\u0026#34;, straddr, \u0026amp;straddr) Printf(\u0026#34;modify strVar value:%v, addr: %p\\n\u0026#34;, addrVal, \u0026amp;addrVal) \u0026gt; strVar value:initial, addr: 0xc0000142b0 \u0026gt; straddr value: 0xc0000142b0, addr: 0xc000012038 \u0026gt; addrVal value:initial, addr: 0xc0000142d0 \u0026gt; strVar value:modify, addr: 0xc0000142b0 // strVar 重新赋值(地址对应的值变化), 地址不变 \u0026gt; straddr value: 0xc0000142b0, addr: 0xc000012038 \u0026gt; addrVal value:initial, addr: 0xc0000142d0 // 地址对应的值没有变化 定义变量后, 该变量的地址不变, 地址内的值可变化\n变量地址 符号: \u0026amp; 获取变量的地址 符号: * 指针变量的值(地址)取值 1 2 3 4 5 6 7 var str string = \u0026#34;hello\u0026#34; // 定义一个字符串变量 str, 值是 \u0026#34;hello\u0026#34; 地址是 0xc00001a078 addr := \u0026amp;str // addr 类型为 *string(地址类型), addr 的值是 0xc00001a078(str 地址), addr 地址是 0xc00000e018 tmp := *addr // 根据 addr 的值(0xc00001a078 str 地址)取值到 \u0026#34;hello\u0026#34; 赋值给 tmp. 等同于 tmp := \u0026#34;hello\u0026#34; *addr = \u0026#34;end\u0026#34; // str 的地址不变, addr 指针一直指向 str 的值, 与 str = \u0026#34;end\u0026#34; 效果一致 ","date":"2022-09-27T19:24:13Z","permalink":"https://facsert.github.io/p/go-%E6%8C%87%E9%92%88/","title":"Go 指针"},{"content":"引申 动态语言与静态语言 动态语言(弱类型语言) 静态语言(强类型语言) 动态语言的变量没有类型, 变量的类型由值的类型决定\n1 2 3 name = \u0026#34;facser\u0026#34; # python 是动态语言 name = 18 # 变量无需声明类型, 可接受任意类型的值 name = [1,2,3] # 变量可随意变换类型, 类型仅在执行时确定 静态语言变量有类型, 且变量类型和值的类型必须一致\n1 2 3 var name string = \u0026#34;facser\u0026#34; // Go 是静态语言 var age int = 18 // 变量声明需要确定变量类型 age = 20 // 变量重新赋值时, 变量和值的类型必须一致 python 类型注解 python 类型注解:\n便于快速理解代码 编辑器的静态类型检查 编辑器类型提示快速开发 注: python 不会做类型检查, 所有类型注解被看做注释用于提示, python 仍然可以使用动态语言特性\n变量注解 1 2 3 4 5 6 7 8 var_str: str = \u0026#34;string\u0026#34; # 字符串变量 var_byte:bytes = b\u0026#39;byte\u0026#39; # byte 类型变量 var_int: int = 3 # 整形变量 var_float: float = 1.6 # 浮点型变量 var_bool: bool = True # 布尔类型变量 none_var: None = None # 定义 None 值 var_any: Any = \u0026#39;any type\u0026#39; # 任意类型(无法确定类型时使用, 减少使用) 容器类型 1 2 3 4 5 6 var_list: list[str] = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] # 列表的值类型只能是字符串 var_set: set[int] = {1,2,3} # 集合的值类型只能是整型 var_dict: dict[str, int] = {\u0026#39;key\u0026#39;: 3} # 字典的 key 为字符串, 值为字符串 var_tuple: tuple[int, str] = [3, \u0026#39;c\u0026#39;] # 元组类型声明和值数量和类型均需要一致 var_tuple2: tuple[int, str] = [\u0026#39;a\u0026#39;, 3, 1] # 错误, 序号1 2值与类型不符, 类型与值数量不一致 注: 上述除元组与字典外, 容器元素只能指定一个类型. 元组需要数量和类型一致, 字典只能使用一组 key value 类型 (python3.9版本前容器类型需要导入 typing 模块的 List Tuple Set Dict)\n联合类型 Union Optional 1 2 3 4 5 6 from typing import Union str_int: Union[str, int] = 2 # 变量可为整形也可为字符串 lst: Union[str, int] = [2, \u0026#39;a\u0026#39;] # 列表的值类型可为字符串或整形 str_int: str | int = 2 # python3.10 的新写法更直观 1 2 3 4 5 6 option_str: Optional[str] = \u0026#39;a\u0026#39; # 可选类型, 值可为字符串或者 None option_int: Optional[int] = None # 可选类型, 值可为整形或者 None Optional[int] = Union[int, None] # Optional 自带 None, 只能再添加一种类型 optional_int: int | None = 3 # python3.10 的新写法 抽象类型 Mapping MutableMapping Sequence Iterable 数组, 元组, 集合\n函数注解 1 2 3 4 5 def func(name: str, age: int) -\u0026gt; dict: # 参数添加类型, 返回值添加类型 return {\u0026#39;name\u0026#39;: name, \u0026#39;age\u0026#39;: age} def func(name: str, age: int=18) -\u0026gt; str, int: # 返回多个值 return name, age Callable 函数, 匿名函数, 包含 call 方法的对象\nCallable[[args_type], return_type]\n1 2 3 4 5 6 7 8 from typing import Callable def func(name: str) -\u0026gt; None: # 函数类型注解, 无返回值则默认返回 None print(f\u0026#34;hellow {name}\u0026#34;) foo: Callable[[str], None] = func # 函数类型注解, 第一个参数是函数参数类型, 第二个是返回值类型 fun: Callable[[int], bool] = lambda x: x is 1 # 匿名函数类型注解 泛型 当对函数使用类型注解时, 参数或返回值有多种类型的可能, 我们会使用 Union 联合类型 但是, 这依然会出现问题, 如我们希望函数参数和返回值类型应当一致\n1 2 3 4 5 6 7 8 9 10 def foo(a:str | int, b:str | int) -\u0026gt; str | int: # 参数可以是整形也可以是字符串 return a + b # 可能出现 a b 类型不一致情况 from typing import TypeVar T = TypeVar(\u0026#39;T\u0026#39;, int, str) # T 类型可以字符串或整数, 第一个参数和变量名一致(T \u0026#39;T\u0026#39;) def foo(a: T, b: T) -\u0026gt; T: # a b 及返回值类型一致 return a + b any = TypeVar(\u0026#39;any\u0026#39;) # 任意类型的泛型 泛型可以使变量表示多种类型同时约束使用该类型的变量为同一类型\n自定义类型 1 2 3 4 5 6 7 8 9 from typing import NewType matrix = NewType(\u0026#39;matrix\u0026#39;, list[list[int]]) # 自定义类型并命名 nums = NewType(\u0026#39;nums\u0026#39;, list[int]) strings = NewType(\u0026#39;strings\u0026#39;, str) a: matrix = matrix([[1,2], [2,3]]) # 需要实例化赋值 b: nums = nums([1,2,3]) c: strings = strings(\u0026#39;str\u0026#39;) 类型别名 1 2 3 4 5 6 7 8 matrix = list[list[int]] # 自定义类型并命名 nums = list[int] strings = str a: matrix = matrix([[1,2], [2,3]]) # 无需实例化与正常类型解一致 b: nums = nums([1,2,3]) c: strings = strings(\u0026#39;str\u0026#39;) class 通过类来定义复杂的组合类型, 类似接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pydantic import BaseModel class Person(BaseModel): id: int name: str age: int email: str victory: Person = Person( id = 3, name = \u0026#39;victory\u0026#39;, age = 18, email = \u0026#39;victory@example.com\u0026#39;, ) ","date":"2022-09-20T16:03:37Z","permalink":"https://facsert.github.io/p/python-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3/","title":"Python 类型注解"},{"content":" 变量 常量 打印 附录 变量 Go 变量命名要求以字母或下划线开头 不可以使用 Go 中的 25 关键字及 37 个保留字 变量要求声明类型或使用类型推导 变量声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var \u0026lt;variable name\u0026gt; \u0026lt;type\u0026gt; = \u0026lt;value\u0026gt; // 使用 var 进行变量定义, 最完整的变量定义 var age int = 18 // 声明变量类型并赋值 var \u0026lt;variable name\u0026gt; \u0026lt;type\u0026gt; // 变量定义, 只定义变量名和类型, 变量默认为对应类型的初始值 var str string // 声明变量和类型, 未赋值使用默认值(string 默认值 \u0026#34;\u0026#34;) var \u0026lt;type\u0026gt; = \u0026lt;value\u0026gt; // 变量定义, 通过值自动推导变量类型 var age = 18 // 声明变量, 赋值, 并使用类型推导 \u0026lt;variable name\u0026gt; := \u0026lt;value\u0026gt; // 变量定义, 通过值自动推导类型, 仅能在函数内部使用 name := \u0026#34;str\u0026#34; // 声明变量, 赋值, 并使用类型推导(仅限于函数内使用) var ( str string // \u0026#34;\u0026#34; 声明变量未赋值, 使用 string 类型默认值 \u0026#34;\u0026#34; num int // 0 声明变量未赋值, 使用 int 类型默认值 0 boolen bool // false 声明变量未赋值, 使用 bool 类型默认值 false ) var ( str string = \u0026#34;hello\u0026#34; // 批量声明并赋值 num int = 4 boolen = true ) str, num := \u0026#34;hello\u0026#34;, 3 // 多个变量声明并赋值 匿名变量 Go 中存在未被使用的变量会报错\n使用匿名变量 \u0026ldquo;_\u0026rdquo; 处理无需使用的变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var name string = \u0026#34;facsert\u0026#34; fmt.Println(\u0026#34;hello world\u0026#34;) \u0026gt; ./main.go:10:6: name declared but not used // 变量 name 未使用, 报错 name, _ := \u0026#34;facsert\u0026#34;, \u0026#34;variable\u0026#34; // 使用匿名变量, 忽略后一个值 fmt.Println(\u0026#34;hello \u0026#34;, name) \u0026gt; hello facsert import { . \u0026#34;fmt\u0026#34; // 使用模块时无需添加模块名称 _ \u0026#34;os\u0026#34; // 引入但未使用的模块, _ 处理后不会报错 } Println(\u0026#34;hello world\u0026#34;) // 引入时使用 . 使调用 fmt 方法无需添加模块名称 常量 常量声明时候必须赋值\n常量一旦声明就不可变化\n1 2 3 4 5 6 7 8 const e = 2.7182 // 常量声明必须要赋值, 且不可更改 const ( // 快速声明常量, a b 赋值 10 a = 10 // a = 10 b // a = 10 继承上一个变量的值 c = 5 // c = 5 d // d = 5 ) iota iota 是定义常量时使用的自增关键字\n同 const 定义块互不干扰, 所有注释行和空行全部忽略\n从第 1 行开始，iota 从 0 逐行加 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const ( a = iota // iota = 0 a = 0 b // iota = 1 b = 1 c // iota = 2 c = 2 ) const ( // 变更初始值 a = iota + 3 // iota = 0 a = 3 b // iota = 1 b = 4 c = iota + 2 // iota = 2 c = 4 d // iota = 3 d = 5 ) const ( // iota 插值 a = iota // iota = 0 a = 0 b = 5 // iota = 1 b = 5 c = iota // iota = 2 c = 2 d // iota = 3 d = 3 ) 打印 通过占位符替换值打印 通过不同占位符可以打印变量不同属性值 万能占用符 %v (%#v %+v 表示不同打印形式) 1 2 3 4 5 6 7 8 9 10 11 fmt.Printf(\u0026lt;str\u0026gt;, \u0026lt;string\u0026gt;, \u0026lt;int\u0026gt;, \u0026lt;bool\u0026gt; ...) // 第一个参数是字符串,后接任意类型值, 占位符需与值数量对应 fmt.Printf(\u0026#34;common: %v \\n\u0026#34;, \u0026#34;common\u0026#34;) // 万能占用符, 自动判断类型 fmt.Printf(\u0026#34;string: %s \\n\u0026#34;, \u0026#34;string\u0026#34;) // 字符串变量占位符 fmt.Printf(\u0026#34;char : %c \\n\u0026#34;, \u0026#39;c\u0026#39;) // 单个字符变量占位符, 单个字符用单引号 fmt.Printf(\u0026#34;number: %d \\n\u0026#34;, 4) // 整形变量占位符 fmt.Printf(\u0026#34;float : %f \\n\u0026#34;, 2.33) // 浮点型变量占位符 fmt.Printf(\u0026#34;bool : %t \\n\u0026#34;, true) // 布尔值变量占位符 fmt.Printf(\u0026#34;point : %p \\n\u0026#34;, *variable) // 指针变量占位符 fmt.Printf(\u0026#34;variable type: %T \\n\u0026#34;, variable) // 变量类型占位符 附录 Golang 中存在一些关键字和保留字， 不能作为变量名称\n关键字 1 2 3 4 5 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import retrun var 保留字 1 2 3 4 5 6 7 8 9 10 Constants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error Functions: make len cap new append copy close delete complex real imag panic recover ","date":"2022-09-19T19:21:13Z","permalink":"https://facsert.github.io/p/go-%E5%8F%98%E9%87%8F/","title":"Go 变量"},{"content":"python excel 模块\n安装 1 $ pip install openpyxl 创建读取 创建表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from openpyxl import Workbook wb = Workbook() # 创建一个工作表 sheet = wb.active # 激活第一个 sheet sheet[\u0026#39;A1\u0026#39;] = \u0026#39;hellow world\u0026#39; # sheet A1 赋值 wb.save(\u0026#39;test.xlsx\u0026#39;) # 保存 excel 文件为 test.xlsx wb.close() # 关闭工作表 wb.create_sheet(name:str [, index:int = -1]) # 自定义 sheet 名称和位置 wb.create_sheet(\u0026#39;first_sheet\u0026#39;, 0) # 在 0 插入 名为 first_sheet 的表 sheet.title # 获取sheet 的名称, 也可以重新赋值 \u0026gt; first_sheet for sheet in wb: # 遍历工作表, 打印所有表名称 print(sheet.title) wb.remove(sheet) # 删除 sheet, 参数是 sheet 对象 读取表 1 2 3 4 5 6 7 8 9 10 from openpyxl import load_workbook wb = load_workbook(\u0026#39;test.xlsx\u0026#39;) # 打开一个已存在的 excel 文件 sheet_names = wb.sheetnames # 获取所有表名组成的列表 \u0026gt; [\u0026#39;first\u0026#39;, \u0026#39;second\u0026#39;, \u0026#39;third\u0026#39;] sheet = wb[\u0026#39;first\u0026#39;] sheet[\u0026#39;A1\u0026#39;] \u0026gt; \u0026#39;hellow world\u0026#39; 读写 赋值和读取 1 2 3 4 5 6 7 8 9 sheet[\u0026#39;A1\u0026#39;] = \u0026#39;hellow world\u0026#39; # A1 赋值 hellow world sheet[\u0026#39;A1\u0026#39;].value # 读取 A1 方格的值 \u0026gt; \u0026#39;hellow world\u0026#39; grid = sheet.cell(row=1, column=1, value=\u0026#39;ok\u0026#39;) # 第一列第一行赋值 ok, 返回一个 cell 对象 sheel.cell(1, 1).value # 读取第一行第一列方格的值 \u0026gt; \u0026#39;ok\u0026#39; row_one = sheet[\u0026#39;A1\u0026#39;: \u0026#39;F1\u0026#39;] # 获取多数方格, 返回 cell 对象的元组 多行遍历 sheet.iter_rows() 每次返回一整行组成的元组 sheet.iter_cols() 每次返回一整列组成的元组 参数 含义 min_row 起始行, default:None max_row 结束行, default:None min_col 起始列, default:None max_col 结束列, default:None values_only True:只返回值, False: 返回 cell 对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 for row in sheet.iter_rows( min_row=1, max_col=3, max_row=2): # 遍历第 1 至第 2 行, 取 3 列 for cell in row: print(cell) \u0026lt;Cell Sheet1.A1\u0026gt; \u0026lt;Cell Sheet1.B1\u0026gt; \u0026lt;Cell Sheet1.C1\u0026gt; \u0026lt;Cell Sheet1.A2\u0026gt; \u0026lt;Cell Sheet1.B2\u0026gt; \u0026lt;Cell Sheet1.C2\u0026gt; for col in sheet.iter_cols( min_row=1, max_col=3, max_row=2): # 遍历第 1 至第 2 行, 取 3 列 for cell in col: print(cell) \u0026lt;Cell Sheet1.A1\u0026gt; \u0026lt;Cell Sheet1.A2\u0026gt; \u0026lt;Cell Sheet1.B1\u0026gt; \u0026lt;Cell Sheet1.B2\u0026gt; \u0026lt;Cell Sheet1.C1\u0026gt; \u0026lt;Cell Sheet1.C2\u0026gt; 样式 字体 1 2 3 4 5 6 7 8 9 10 11 from openpyxl.styles import Font cell.font = Font( name=\u0026#34;微软雅黑\u0026#34;, # 字体 size=15, # 字体大小 color=\u0026#34;0000FF\u0026#34;, # 字体颜色，用16进制rgb表示 bold=True, # 是否加粗，True/False italic=True, # 是否斜体，True/False strike=None, # 是否使用删除线，True/False underline=None, # 下划线, 可选\u0026#39;singleAccounting\u0026#39;, \u0026#39;double\u0026#39;, \u0026#39;single\u0026#39;, \u0026#39;doubleAccounting\u0026#39; ) 填充颜色 1 2 3 4 5 6 7 8 9 10 11 from openpyxl.styles import PatternFill cell.fill = PatternFill( patternType=\u0026#34;solid\u0026#34;, # 填充类型 fgColor=\u0026#34;F562a4\u0026#34;, # 前景色，16进制rgb bgColor=\u0026#34;0000ff\u0026#34;, # 背景色，16进制rgb ) patternType: # patternType 可选值 none、solid、darkGray、mediumGray、lightGray、 lightDown、lightGray、lightGrid 边框 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from openpyxl.styles import Border, Side side = Side( style=\u0026#34;medium\u0026#34;, # 边框样式 color=\u0026#34;ff66dd\u0026#34;, # 边框颜色，16进制rgb表示 ) style: # style 可选值 dashDot、dashDotDot、dashed、dotted、double、 hair、medium、mediumDashDot、mediumDashDotDot、 mediumDashed、slantDashDot、thick、thin cell.border = Border( top=side, # 上边框使用定义的 side bottom=side, # 下边框使用定义的 side left=side, # 左边框使用定义的 side right=side, # 右边框使用定义的 side diagonal=side # 对角线使用定义的 side ) 对齐 1 2 3 4 5 6 7 8 9 10 from openpyxl.styles import Alignment cell.alignment = Alignment( horizontal=\u0026#39;left\u0026#39;, # 水平对齐，可选general、left、center、right、fill、justify、centerContinuous、distributed vertical=\u0026#39;top\u0026#39;, # 垂直对齐， 可选top、center、bottom、justify、distributed text_rotation=0, # 字体旋转，0~180整数 wrap_text=False, # 是否自动换行 shrink_to_fit=False, # 是否缩小字体填充 indent=0, # 缩进值 ) ","date":"2022-09-05T20:12:37Z","permalink":"https://facsert.github.io/p/python-openpyxl/","title":"Python openpyxl"},{"content":"最近使用 mac 的时候发现, mac 默认的 shell 是 zsh, 顺手查了一下 bash 和 zsh 区别\nzsh 介绍 zsh能基本完美兼容bash的命令，并且使用起来更加优雅\n命令提示 智能补全 快速跳转 热键绑定 框架主题 命令提示 1 2 3 4 5 6 $ command \u0026lt;Tab\u0026gt; # 输入命令, 按下 Tab 会显示可执行参数 $ date -\u0026lt;Tab\u0026gt; # 使用 Tab 查看提示 \u0026gt; --date -d -- output date specified by string \u0026gt; --help -- output help and exit \u0026gt; --file -f -- output dates specified in file 智能补全 1 2 3 4 $ cd /h/f/D \u0026lt;Tab\u0026gt; # 路径缩写补全 \u0026gt; cd /home/facser/Desktop/ $ cd /home/facser/ \u0026lt;Tab\u0026gt; \u0026lt;Tab\u0026gt; # 连续两次 Tab 进入选择模式 快速跳转 1 2 3 4 5 6 7 $ d # 执行 d 命令, 列出之前进入的目录, 数字选择 \u0026gt; 0 ~/Desktop \u0026gt; 1 ~/Desktop/test \u0026gt; 2 ~ \u0026gt; 3 ~root $ cd - \u0026lt;Tab\u0026gt; # 同上, 列出之前目录, 通过数字选择 1 2 3 4 5 6 7 8 9 10 $ alias # 列出所有快捷命令 cd .. =\u0026gt; ... # 常用的命令热键 cd - =\u0026gt; - git status =\u0026gt; gst git log --stat =\u0026gt; glg git add --all =\u0026gt; gaa git commit -a -s =\u0026gt; gcas git push origin {curr_branch} =\u0026gt; ggpush git pull origin {curr_branch} =\u0026gt; ggpull 框架主题 安装 oh-my-zsh 更换主题, 添加插件\nzsh 安装与配置 下载安装 1 2 3 $ sudo apt install zsh # Ubuntu 直接下载安装 $ yum install zsh # Centos Redhat yum 安装版本低无法添加 oh-my-zsh 启动与环境 1 2 3 4 5 6 7 8 $ zsh # 使用 zsh 命令启动 zsh $ echo $SHELL # 查看当前 shell $ which zsh # 查看 zsh 执行文件位置 $ chsh -s /bin/zsh # /bin/zsh 需要和 zsh 执行文件位置一致 $ ~/.zshrc # 启动 zsh 时执行的配置文件 $ source ~/.zshrc # 配置立即生效 注: .zshrc 可删除, 启动 zsh 未发现 .zshrc 文件会提示重新配置 zsh\n配置 .oh-my-zsh 1 2 3 $ sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; $ sh -c \u0026#34;$(curl -fsSL https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)\u0026#34; 注: .oh-my-zsh 默认安装在 ~/.oh-my-zsh, 主题夹为 ~/.oh-my-zsh/themes\nzsh 配置主题 1 2 3 4 $ vi ~/.zshrc # 修改 zsh 配置文件 \u0026gt; ZSH_THEME=\u0026#34;\u0026lt;主题\u0026gt;\u0026#34; # 更换 .oh-my-zsh 主题 \u0026gt; export ZSH=\u0026#34;\u0026lt;.oh-my-zsh位置\u0026gt;\u0026#34; # 定义 .oh-my-zsh 位置 注: .oh-my-zsh 的位置是可变的, 只要在 .zshrc 配置中指定即可\npowerlevel10k .oh-my-zsh 有很多主题可更换, powerlevel10k 是另外一款爆火的主题\n1 2 3 4 5 6 7 8 $ git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k $ vi ~/.zshrc # 修改 zsh 主题 \u0026gt; ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; $ source ~/.zshrc # 配置立即生效 $ p10k configure # 重新设置主题配置 注: 配置生效后, 自动进入配置选项, 逐一选择即可\nzsh-syntax-highlighting 错误语法高亮, 正确命令绿色, 错误命令红色\n1 2 3 4 5 6 7 8 9 $ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting $ vi ~/.bashrc # 编辑 zsh 配置文件, plugins 添加插件 \u0026gt; plugins=( \u0026gt; ... \u0026gt; zsh-syntax-highlighting \u0026gt; ) $ source ~/.zshrc # 配置立即生效 zsh-autosuggestions 补全历史命令\n1 2 3 4 5 6 7 8 9 $ git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions $ vi ~/.bashrc # 编辑 zsh 配置文件, plugins 添加插件 \u0026gt; plugins=( \u0026gt; ... \u0026gt; zsh-autosuggestions \u0026gt; ) $ source ~/.zshrc # 配置立即生效 z 仅输入文件即可跳转到曾经进入的文件目录(oh-my-zsh自带,无需下载)\n1 2 3 4 5 6 7 8 9 10 11 12 $ vi ~/.bashrc # 编辑 zsh 配置文件, plugins 添加插件 \u0026gt; plugins=( \u0026gt; ... \u0026gt; z \u0026gt; ) $ source ~/.zshrc # 配置立即生效 $ ~/Desktop/zsh/a/b/c # 进入过 c 文件目录 $ ... # 随意进入其他路径 $ $ z c # z 命令加文件夹名即可回去 extract 一键解压 tar, gz, zip, rar 包(oh-my-zsh自带,无需下载)\n1 2 3 4 5 6 7 8 $ vi ~/.bashrc # 编辑 zsh 配置文件, plugins 添加插件 \u0026gt; plugins=( \u0026gt; ... \u0026gt; extract \u0026gt; ) $ x package.tar.gz # x 命令加压缩包即可解压 $ x package.zip ","date":"2022-08-31T21:46:19Z","permalink":"https://facsert.github.io/p/zsh/","title":"Zsh"},{"content":"eval 使用 eval 能评估字符串转换为表达式, 返回表达式的值\n1 2 3 4 5 6 7 8 9 10 eval(string[, globals: dict[, locals:dict]]) # 后两个参数类型为字典 eval(string, None, None) # 后两个默认参数, 默认值为 None a, b = 1, 2 eval(\u0026#39;a + b\u0026#39;) # 将字符串转换成表达式 \u0026gt; 3 # 返回表达式的执行结果 variable = -2 eval(\u0026#39;abs(variable)\u0026#39;) # 使用内置函数 \u0026gt; 2 限定范围 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 eval(string, None, local:dict) # 所有全局变量可用, 局部变量限定字典内 eval(string, global:dict, None) # 所有局内变量可用, 全局变量限定字典内 glo_var = \u0026#39;global variable\u0026#39; def eval_test(): loc_val = \u0026#39;local variable\u0026#39; eval(\u0026#39;print(glo_val + loc_val)\u0026#39;, {}, None) # 全局变量受限, 无法识别 glo_var \u0026gt; name \u0026#39;glo_val\u0026#39; is not defined glo_var = \u0026#39;global variable\u0026#39; def eval_test(): loc_val = \u0026#39;local variable\u0026#39; eval(\u0026#39;print(glo_val + loc_val)\u0026#39;, None, {}) # 局内变量受限, 无法识别 loc_val \u0026gt; name \u0026#39;loc_val\u0026#39; is not defined glo_var = \u0026#39;global variable\u0026#39; def eval_test(): loc_val = \u0026#39;local variable\u0026#39; eval(\u0026#39;print(glo_val + loc_val)\u0026#39;, {}, {}) # 局内变量, 全局变量均受限 \u0026gt; name \u0026#39;loc_val\u0026#39; is not defined glo_var = \u0026#39;global variable\u0026#39; def eval_test(): loc_val = \u0026#39;local variable\u0026#39; eval(\u0026#39;print(glo_val + loc_val)\u0026#39;, None, None) # 变量取值不受限制, 正常取值 \u0026gt; name \u0026#39;loc_val\u0026#39; is not defined 安全性 全局变量存在一个内置命名空间, 包含很多常用函数和属性(无需导入即可使用)\n1 2 3 4 5 6 7 8 eval(\u0026#39;abs(a)\u0026#39;, {a: -3}, {}) # 全局变量和局内变量只提供一个变量, 还是能识别 abs 函数 \u0026gt; 3 eval(string, {\u0026#39;__builtins__\u0026#39;: None}) eval(\u0026#39;abs(-3)\u0026#39;, {\u0026#39;__builtins__\u0026#39;: None}, None) # global 隐式携带内置命名空间, 必须显式声明, {} 无效 \u0026gt; \u0026#39;NoneType\u0026#39; object is not subscriptable 注: 避免将未知字符转换为代码, 需要屏蔽 python 内置函数和属性\nexec 使用 exec 将字符串转换为代码块, 返回值为 None\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 exec(string[, globals: dict[, locals:dict]]) # 后两个参数类型为字典 exec(string, None, None) # 后两个默认参数, 默认值为 None exec(\u0026#39;a = 2 + 3\u0026#39;) # 与正常执行语句一致 print(a) \u0026gt; 3 eval(\u0026#39;a = 2 + 3\u0026#39;) # eval 无法执行语句 ^ SyntaxError: invalid syntax a = exec(\u0026#39;2 + 3\u0026#39;) # exec 也可执行表达式, 但返回值为 None print(a) \u0026gt; None a = eval(\u0026#39;2 + 3\u0026#39;) # eval 能正常返回表达式结果 print(a) \u0026gt; 5 限定范围 与 eval 一致\n安全性 与 eval 一致\n","date":"2022-08-30T22:22:31Z","permalink":"https://facsert.github.io/p/python-eval-exec/","title":"Python eval exec"},{"content":"if 分支 if 分支是 shell 中的最常见的分支\n1 2 3 4 5 6 7 8 9 10 11 if \u0026lt;expression\u0026gt; ; then # expression 返回值为 0 表示条件成立 commands # 表达式成立才会执行 command fi if [[ 3 \u0026gt; 2 ]]; then # 3 \u0026gt; 2 条件成立 echo -e \u0026#34; 3 bigger thean 2\\n\u0026#34; # 执行打印 fi $ if date; then echo \u0026#34;true\u0026#34;; fi # 命令执行成功也表示条件成立 \u0026gt; Mon Aug 15 21:03:03 CST 2022 # date 命令执行成功 \u0026gt; true # 执行分支代码 注: if 分支后的命令或表达式返回 0 表示 true, 条件成立, 其余值均表示 false 不成立\n多重分支 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if \u0026lt;expression\u0026gt;; then # command 返回值为 0 表示条件成立 commands elif \u0026lt;expression\u0026gt;; then # if 不成立, 判断 elif commands else # if 和 elif 均不成立才执行 commands fi if true; then # 命令执行成功表示条件成立 echo \u0026#34;first if\u0026#34;; elif true; then # 上个 if 条件不成立才会执行判断 echo \u0026#34;else if\u0026#34;; else # 上述分支均不成立才会执行 echo \u0026#34;else\u0026#34;; fi \u0026gt; first if # 执行第一个成立的 if 条件 表达式 表达式有很多形式, 数值或字符串比较需要使用括号包含\nLinux 命令也可以作为表达式, 命令返回值 0 为 true, 返回值不为 0 为 false\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 test \u0026lt; expression \u0026gt; # 常用作 if 判断的表达式, 与 [ expression ] 等价 [ expression ] # 同上, 与 test 等价, 括号内空格是必须的 [[ expression ]] # 较上述额外支持正则, 括号内空格是必须的 if [[ $USER == \u0026#34;root\u0026#34; ]]; then echo \u0026#34;user is root\u0026#34; else echo \u0026#34;not user root\u0026#34; fi $ [[ $USER == \u0026#34;root\u0026#34; ]] \u0026amp;\u0026amp; echo \u0026#34;user is root\u0026#34; # \u0026amp;\u0026amp;(且) 表达式为 true 才会执行后半段 $ [[ $USER == \u0026#34;root\u0026#34; ]] || echo \u0026#34;not user root\u0026#34; # ||(或) 表达式为 false 才会执行后半段 $ true \u0026amp;\u0026amp; echo $? # true 返回值为 0, 前半部分 true, 继续执行后半段 \u0026gt; 0 $ false || echo $? # false 返回值 1, 前半部分 false, 继续执行后半段 \u0026gt; 1 注: 单括号需要注意变量引用为空导致命令报错或逻辑错误\n[ $name == \u0026quot;bash\u0026quot; ] 当 $name 为空执行会报错\n数值比较 单中括号数值比较不支持 \u0026gt; \u0026lt; == 等符号, 使用 -eq -ne -lt -le -gt -ge 代替\n双中括号数值比较支持 \u0026gt; \u0026lt; == 符号也支持 -eq -ne -lt -le -gt -ge\n1 2 3 4 5 6 7 8 9 10 11 12 $ [ 3 -eq 3 ] # equal 数值相等表示 true $ [ 3 -ne 3 ] # not equal 数值不相等表示 true $ [ 3 -lt 3 ] # less than 小于 $ [ 3 -le 3 ] # less equal 小于等于 $ [ 3 -gt 3 ] # greater than 大于 $ [ 3 -ge 3 ] # greater equal 大于等于 $ [ 0 -ne 0 ]; echo $? \u0026gt; 0 $ [ 3 \u0026gt; 2 ] \u0026amp;\u0026amp; echo \u0026#34;true\u0026#34; # 执行命令 \u0026#34;3\u0026#34; 结果写入 2 文件, 执行成功打印 true \u0026gt; true 注: 数值比较尽量不要使用 \u0026gt; \u0026lt; ==等符号, 使用双中括号和字符比较\n字符串比较 1 2 3 4 5 6 7 8 9 10 11 12 $ [ -z \u0026#34;str\u0026#34; ] # 字符串长度为 0 为 true $ [ -n \u0026#34;str\u0026#34; ] # 字符串长度不为 0 为 true $ [ \u0026#34;abc\u0026#34; == \u0026#34;abc\u0026#34; ] # 字符串相等为 true $ [ \u0026#34;abc\u0026#34; != \u0026#34;abc\u0026#34; ] # 字符串不相等为 true $ name=\u0026#34;\u0026#34; $ [ $name == \u0026#34;linux\u0026#34; ] || echo \u0026#34;no linux\u0026#34; # name 为空, 从 == 开始执行, 报错 \u0026gt; bash: [: ==: unary operator expected $ [[ $name = \u0026#34;linux\u0026#34; ]] || echo \u0026#34;no linux\u0026#34; \u0026gt; no linux 文件比较 1 2 3 4 5 6 7 8 $ [ -e file ] # 文件存在为 true $ [ -d file ] # 路径存在为 true $ [[ ! -e file ]] \u0026amp;\u0026amp; touch file # 如果 file 不存在则创建 file $ [[ ! -d /root/path ]] \u0026amp;\u0026amp; mkdir -p /root/path # 如果路径不存在测创建路径 $ [ -f file ] \u0026amp;\u0026amp; cat file || echo \u0026#34;1st\u0026#34; \u0026gt; file # file 存在则读取 file, 不存在则创建并写入 \u0026#34;1st\u0026#34; \u0026gt; 1st 正则判断 1 2 3 4 5 [[ expression ]] # 仅双括号支持正则表达式 [[ \u0026#34;abc\u0026#34; =~ \u0026#34;b\u0026#34; ]] # true 判断 abc 是否包含 b [[ \u0026#34;01:01:01\u0026#34; =~ ([0-9]{2}\\:){2}[0-9]{2} ]] # true 正则匹配时间格式, 正则表达式不能用引号包含 [[ \u0026#34;10.0.0.1\u0026#34; =~ ([0-9]{1,3}\\.){3}[0-9]{1,3} ]] # true 正则匹配 IPV4 逻辑判断 1 2 3 4 5 6 7 8 [ ! expression ] # 单括号逻辑非 [[ ! expression ]] # 双括号逻辑非 [ true -a true ] # true 单括号逻辑与 [[ true \u0026amp;\u0026amp; false ]] # false 双括号逻辑与 [ false -o true ] # true 单括号逻辑或 [[ false || true ]] # true 双括号逻辑或 逻辑运算 逻辑与 1 2 3 4 5 6 7 8 9 10 11 12 $ command \u0026amp;\u0026amp; command # 前一条命令成功才会执行后一条 $ true \u0026amp;\u0026amp; echo \u0026#34;true\u0026#34; # true 返回值 0, 继续执行 \u0026gt; true ! false \u0026amp;\u0026amp; echo \u0026#34;not false\u0026#34; # 前一条命令返回值 0, 继续执行 \u0026gt; not false $ command || command # 前一条失败后才会继续执行后一条 $ false || echo \u0026#34;false\u0026#34; # false 返回值 1, 执行下一条 \u0026gt; false switch ","date":"2022-08-21T22:24:10Z","permalink":"https://facsert.github.io/p/bash-%E6%8E%A7%E5%88%B6%E6%B5%81/","title":"Bash 控制流"},{"content":"包管理工具 yum ellowdogUpdater,Modified: centos redhat 包管理器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ yum \u0026lt;opt\u0026gt; \u0026lt;pack\u0026gt; # RedHat Centos 包管理工具 $ yum install \u0026lt;pack\u0026gt; # 下载安装包 $ yum update \u0026lt;pack\u0026gt; # 更新已安装的包 $ yum remove \u0026lt;pack\u0026gt; # 卸载已安装的包 $ yum search \u0026lt;pack\u0026gt; # 检查软件包的信息 $ yum list # 列出所有已安装的包 $ yum list installed \u0026lt;pack\u0026gt; # 检查包是否安装 $ yum list | grep zsh \u0026gt; Repodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fast \u0026gt; zsh.x86_64 5.0.2-34.el7_8.2 base \u0026gt; zsh-html.x86_64 5.0.2-34.el7_8.2 base 注: yum 配置文件 /etc/yum.repos.d/ 只下载安装包而不安装 command: yum reinstall --downloadonly --downloaddir=\u0026lt;path\u0026gt; \u0026lt;package name\u0026gt;\nrpm RedHat Package Manager\n1 2 3 4 5 6 7 8 $ rpm \u0026lt;opt\u0026gt; \u0026lt;pack\u0026gt; $ rpm -i \u0026lt;pack\u0026gt; # 安装 rpm 包 -v # 显示安装信息 -h # 安装包时列出标记 -e # 卸载 rpm 包 $ rpm -ivh \u0026lt;pack\u0026gt; # 安装 rpm 包, 显示安装过程 apt-get Advanced Package Tool get: ubuntu debian 的包管理器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ apt \u0026lt;opt\u0026gt; \u0026lt;pack\u0026gt; $ apt-get install \u0026lt;pack\u0026gt; # 下载并安装软件包 $ apt-get remove \u0026lt;pack\u0026gt; # 卸载已安装的软件包 $ apt-get upgrade # 更新所有已安装的软件包 $ apt-get update # 更新软件包列表 $ apt install \u0026lt;pack\u0026gt; # apt 集成 apt-get 功能 $ apt download \u0026lt;pack\u0026gt; # 仅下载包, 不安装 $ apt search \u0026lt;pack\u0026gt; # 查找 包 $ apt remove \u0026lt;pack\u0026gt; # 卸载已安装的包 $ apt list --installed | grep zsh # 列出已安装的包 \u0026gt; zsh-common/oldstable,oldstable,now 5.7.1-1+deb10u1 all [installed,automatic] \u0026gt; zsh/oldstable,oldstable,now 5.7.1-1+deb10u1 amd64 [installed] 注: OS 默认下载源文件 /etc/apt/source.list 只下载包而不安装, (下载的包会存放在 /var/cache/apt/archives) command: apt install -d \u0026lt;package name\u0026gt;\ndpkg Debian package: 离线包安装\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ dpkg \u0026lt;opt\u0026gt; \u0026lt;pack\u0026gt; $ dpkg -i \u0026lt;pack\u0026gt; # 安装 deb 安装包 $ dpkg -r \u0026lt;pack\u0026gt; # 卸载 deb 包 $ dpkg -l # 列出所有安装的包 \u0026gt; Desired=Unknown/Install/Remove/Purge/Hold \u0026gt; | Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend \u0026gt; |/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad) \u0026gt; ||/ Name Version Architecture Description \u0026gt; +++-=========================================-==========================================-============-=========== \u0026gt; ii acl 2.2.53-4 amd64 access control list - utilities \u0026gt; ii adduser 3.118 all add and remove users and groups \u0026gt; ii adwaita-icon-theme 3.30.1-1 all default icon theme of GNOME \u0026gt; ii alien 8.95 all convert and install rpm and other packages \u0026gt; ii apache2 2.4.38-3+deb10u4 amd64 Apache HTTP Server 压缩 解压 tar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ tar \u0026lt;opt\u0026gt; \u0026lt;pack\u0026gt; $ tar -zxvf \u0026lt;package name\u0026gt; -C \u0026lt;path\u0026gt; # 解压 tar.gz 压缩包到 \u0026lt;path\u0026gt; 路径 \u0026gt; tar -zxvf package.tar.gz -C /root/ # 将 package.tar.gz 解压到 /root/ 目录下 $ tar -zcvf \u0026lt;package name\u0026gt; \u0026lt;file|dir\u0026gt; # 将文件或目录压缩 \u0026gt; tar -zcvf learn.tar.gz learn/ # 将当前目录下的 learn 文件夹压缩成 learn.tar.gz $ tar -ztvf \u0026lt;tar.gz\u0026gt; # 列出压缩包的文件 \u0026gt; drwxr-xr-x root/root 0 2023-04-03 03:24 test/ \u0026gt; -rw-r--r-- root/root 0 2023-04-03 03:24 test/3rd \u0026gt; -rw-r--r-- root/root 0 2023-04-03 03:24 test/2nd \u0026gt; -rw-r--r-- root/root 0 2023-04-03 03:24 test/1st parameter meaning -c, --create 创建一个新归档 -f, --file=ARCHIVE 使用归档文件或 ARCHIVE 设备 -t, --list 列出归档内容 -v, --verbose 详细地列出处理的文件 -x, --extract, --get 从归档中解出文件 -z, --gzip, --gunzip, --ungzip 通过 gzip 过滤归档 zip 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ zip \u0026lt;opt\u0026gt; \u0026lt;pack\u0026gt; $ zip \u0026lt;package name\u0026gt; \u0026lt;file\u0026gt; # 压缩文件成 zip 包 $ zip -r \u0026lt;package name\u0026gt; \u0026lt;path\u0026gt; # 压缩文件夹成 zip 包 \u0026gt; zip -r learn.zip learn/ # 将当前目录下的 learn 文件夹压缩成 learn.zip $ unzip \u0026lt;package name\u0026gt; # 解压 zip 压缩包 $ unzip -v \u0026lt;zip\u0026gt; # 查看 zip 压缩文件内容 \u0026gt; Archive: test.zip \u0026gt; Length Method Size Cmpr Date Time CRC-32 Name \u0026gt; -------- ------ ------- ---- ---------- ----- -------- ---- \u0026gt; 0 Stored 0 0% 2023-04-03 03:24 00000000 test/ \u0026gt; 0 Stored 0 0% 2023-04-03 03:24 00000000 test/3rd \u0026gt; 0 Stored 0 0% 2023-04-03 03:24 00000000 test/2nd \u0026gt; 0 Stored 0 0% 2023-04-03 03:24 00000000 test/1st \u0026gt; -------- ------- --- ------- \u0026gt; 0 0 0% 4 files ","date":"2022-08-19T15:02:16Z","permalink":"https://facsert.github.io/p/linux-%E5%8C%85%E7%AE%A1%E7%90%86/","title":"Linux 包管理"},{"content":"BASH 教程\nBASH 基础语法\n1 2 3 4 5 6 7 8 9 10 $ command \u0026lt;option\u0026gt; \u0026lt;args\u0026gt; # shell 命令一般格式 $ cat -n log.txt # 读取 log.txt 文件, 命令 cat, 选项 -n, 参数 log.txt \u0026gt; 1 1st \u0026gt; 2 2nd \u0026gt; 3 3rd $ command | \u0026lt;command\u0026gt; | \u0026lt;command\u0026gt; # 命令管道 $ cat log.txt | grep \u0026#34;3rd\u0026#34; # 管道前的值作为管道后命令的参数 \u0026gt; 3rd 打印输出 echo 1 2 3 4 5 6 7 8 9 $ echo \u0026lt;opt\u0026gt; \u0026lt;string\u0026gt; # 打印 string 内容, 不激活转义符号 $ echo -e \u0026lt;string\u0026gt; # 激活字符中的转义字符 $ echo \u0026#34;first \\nsecond\u0026#34; \u0026gt; first \\nsecond $ echo -e \u0026#34;first \\nsecond\u0026#34; \u0026gt; first \u0026gt; second 注: 更多转义符号浏览 转义符号\nprintf 1 2 3 4 5 6 7 $ printf \u0026lt;format string\u0026gt; # 格式化输出字符串 $ printf \u0026#34;%s length is %.3f\u0026#34; \u0026#34;line\u0026#34; \u0026#34;4.53245\u0026#34; # 字符串格式化 \u0026gt; line length is 4.523 $ printf \u0026#34;%-6s_%s\u0026#34; \u0026#34;left\u0026#34; \u0026#34;right\u0026#34; # 默认右对齐, 带 - 左对齐, 数字表示占位 \u0026gt; left _rightf 变量引用 BASH 只有字符串一种数据类型, 想要操作字符串或者引用变量需要使用特殊符号\n1 2 3 4 5 6 7 8 9 10 11 $ variable=\u0026#34;hello world\u0026#34; # 变量赋值, \u0026#39;=\u0026#39; 号前后不允许空格 $ temp=hello_world # 字符串无引号赋值时不允许空格 $ echo variable # 把打印内容当做字符串直接打印 \u0026gt; variable $ echo $variable # 打印变量的值 \u0026gt; hello world $ echo say_${temp}_to_code # 字符连用时, 用 {} 区分变量 \u0026gt; say_hello_world_to_code 建议字符串操作时, 添加引号使变量操作更加明确(易于区分编辑器中字符串与变量)\n引号 单引号与双引号 BASH 区分单引号和双引号, 单引号内全部为当做字符(转义符有效), 双引号会激活变量引用\n1 2 3 4 5 6 7 $ name=\u0026#34;petter\u0026#34; $ echo \u0026#39;hello\\t$name\u0026#39; # 单引号禁止变量名扩展, 原样打印 \u0026gt; hello $name $ echo \u0026#34;hello\\t$name\u0026#34; # 双引号允许变量名扩展 \u0026gt; hello petter 反引号 反引号用于执行命令, 一般用于将命令结果赋值给变量\n1 2 3 4 5 $ time=`date` # 将 data 命令结果赋值给 time $ echo \u0026#34;$time\u0026#34; # 打印变量值 \u0026gt; Wed Aug 10 21:49:38 HKT 2022 $ time=$(date) # 与反引号效果一致 由于反引号易于与单引号混淆, 建议使用 $() 方式, 便于区分\n变量 环境变量 BASH 环境中的变量, 系统自定义的全局变量, 变量名全为大写, 用于保存环境信息\n1 2 3 4 5 6 7 8 9 10 $ env # 显示所有环境变量 $ echo $HOME # 打印用户目录 \u0026gt; /home/facser $ echo $PATH # 运行环境目录组成的列表 $ export \u0026lt;var\u0026gt;=\u0026lt;val\u0026gt; # 自定义环境变量, 新开窗口或重启失效 $ unset \u0026lt;var\u0026gt; # 删除变量, 环境变量和自定义变量均可 $ set \u0026lt;var\u0026gt; # 显示所有 shell 变量 注: 更多环境变量浏览 环境变量\n自定义变量 1 2 3 4 5 $ \u0026lt;var\u0026gt;=\u0026lt;val\u0026gt; # 变量定义, 等号两边不允许空格 $ $\u0026lt;char\u0026gt; # 如 $? #! 等特殊含义变量 $ echo $? # 上个命令返回值 \u0026gt; 0 # 0 表示命令执行成功, 其它只表示失败或错误 注: 更多特殊变量 特殊变量\n1 2 3 4 5 6 7 8 $ ${variable:-value} # 变量为空或不存在返回 value $ ${variable:+value} # 变量存在且不为空返回 value $ ${variable:=value} # 变量为空或不存在设置变量为 value, 返回 values $ ${variable:?message} # 变量为空或不存在打印 message, 并退出 $ echo \u0026#34;hello ${name:-petter}\u0026#34; \u0026gt; hello petter 1 2 3 4 5 6 7 $ declare \u0026lt;opt\u0026gt; \u0026lt;var\u0026gt;=\u0026lt;val\u0026gt; # 定义特殊类型变量 $ declare -i int1=8 int2=6 sum # 定义整数变量, 可直接数学运算 $ sum=int1*int2; echo $sum # 声明整数变量可直接数学运算 \u0026gt; 14 $ declare -a arr=(1 2 3) # 定义数组变量 1 2 3 4 5 6 $ let \u0026lt;var\u0026gt;=\u0026lt;expression\u0026gt; # 声明含算术表达式的变量 $ let \u0026#34;sum = 7 + 8\u0026#34; $ let \u0026#34;add = sum++\u0026#34; $ echo \u0026#34;sum: $sum add: $add\u0026#34; \u0026gt; sum: 15 add: 16 输出重定向 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ command 2\u0026gt;\u0026amp;1 # 1 表示标准输出 2 表示标准错误输出 \u0026gt; zsh: command not found: data $ command 2\u0026gt;/dev/null # 将错误写入 null, 即不显示错误 \u0026gt; $ command \u0026gt; file # 清空文件内容, 命令标准输出写入文件 $ date \u0026gt; log.txt; cat log.txt \u0026gt; Mon Jul 3 23:05:14 CST 2023 $ command \u0026gt;\u0026gt; file # 保留文件内容, 命令标准输出追加入文件 $ date \u0026gt;\u0026gt; log.txt; cat log.txt \u0026gt; Mon Jul 3 23:05:14 CST 2023 \u0026gt; Mon Jul 3 23:05:38 CST 2023 $ command \u0026gt; /dev/null # 命令标准输出写入 null, 即不显示正常结果 \u0026gt; 常用转义符号 符号 含义 \\n 换行符 \\r 回车, 回到行首 \\t Tab 键 \\b 光标左移 1 位 常用环境变量 变量 含义 HOME 当前用户目录 USER 当前用户 SHELL 当前使用的 shell PATH 环境变量 PWD 当前目录 特殊变量 变量 含义 $? 上一个命令的返回值 $! 上一个命令的 pid $$ 当前 shell 进程 $@ 当前函数或脚本的所有参数 ","date":"2022-08-09T21:20:45Z","permalink":"https://facsert.github.io/p/bash-%E5%9F%BA%E7%A1%80/","title":"Bash 基础"},{"content":"网络配置 Debian 网络配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ vi /etc/network/interfaces auto enp125s0f0 # 网卡名 iface enp125s0f0 inet static # 设置静态 IP address 10.58.14.96/24 # 设置 IP 地址和掩码 gateway 10.10.10.1 # 设置网关 auto enp125s0f0 # 网卡名称 iface enp125s0f0 inet dhcp # 设置动态 IP address 10.58.14.96/24 # 设置 IP 地址和子网掩码 gateway 10.10.10.1 # 设置网关 $ systemctl restart networking # 重启网络服务 Centos\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 vi /etc/sysconfig/network-scripts/ifcfg-eth0 TYPE=Ethernet # 类型=以太网络 PROXY_METHOD=none # 代理模式 BROWSER_ONLY=no DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes # 启用IPV6协议 IPV6_AUTOCONF=yes # 自动配置IPV6地址 IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens32 UUID=0e6d72a7-8a6c-43ac-aef2-25d165562fd0　DEVICE=eth0 # 设备名称 BOOTPROTO=none # 开机协议 static dhcp none ONBOOT=yes # 启动或重启网络时，启动该设备，yes启动，no不启动 IPADDR=192.168.1.15 # IPV4 地址 PREFIX=24 # 子网掩码 GATEWAY=192.168.1.1 # 网关 DNS1=192.168.1.2 # DNS服务器地址 IPV6_PRIVACY=no # IPV6协议 $ systemctl restart network # 重启网络 配置 ssh 1 2 3 4 5 6 7 8 9 $ vi /etc/ssh/sshd_config # 编辑 ssh 系统配置文件 #PermitRootLogin prohibit-password PermitRootLogin yes # 允许远程 root 用户登录 #PasswordAuthentication no PasswordAuthentication yes # 允许用户密码作为口令验证 $ systemctl restart sshd # 重启 ssh 服务，令配置生效 host 配置 命令行开头 root@debian:~/#\nroot: 用户名称 debian: Linux host 名称 ~/: 当前目录 #: root 用户标识(普通用户为 $) 1 2 3 4 5 6 7 8 9 $ hostname # 打印本机 hostname \u0026gt; debian $ hostname -i # 打印本机 IP \u0026gt; debian $ hostnamectl set-hostname ubuntu # 修改 hostname, 立即生效 $ hostname \u0026gt; ubuntu 通过 /etc/hosts 文件可以将主机名与 IP 绑定快速解析\n1 2 3 4 5 $ vi /etc/hosts # 域名解析为 IP 地址的配置文件 127.0.0.1 localhost # localhost 会被解析为 IP 127.0.0.1 192.168.1.49 node # node 被解析为对应 IP, 例如 ping node == ping 192.168.1.49 123.123.123.123 baidu 通过 /etc/resolve.conf 指定 DNS 解析的服务器地址 用户通过域名访问网站, 请求发送到 DNS 服务器, DNS 服务器将域名解析为具体的 IP 返回给用户机器\n1 2 3 4 5 6 $ vi /etc/resolve.conf nameserver 8.8.8.8 # 添加 DNS 解析服务器 IP 地址 nameserver 10.10.10 # 添加 DNS 解析服务器 IP 地址 $ source /etc/resolve.conf # 配置生效 1 2 www.baidu.com 123.123.123.123 123.123.123.123 computer -------\u0026gt; DNS server -------\u0026gt; computer -------\u0026gt; baidu server Windows WSL ssh 连接 WSL 下查看 ssh 服务端口\n1 2 3 4 5 6 7 8 9 10 $ ss -ntlp | grep ssh # Debian Ubuntu 默认端口查看工具 \u0026gt; LISTEN 0 128 0.0.0.0:2222 0.0.0.0:* users:((\u0026#34;sshd\u0026#34;,pid=4628fd=4)) \u0026gt; LISTEN 0 128 [::]:2222 [::]:* users:((\u0026#34;sshd\u0026#34;,pid=4628,fd=3)) $ netstat -ntlp | grep ssh # Redhat Centos netstat 查看端口 \u0026gt; tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN 4628/sshd: /usr/sbi \u0026gt; tcp6 0 0 :::2222 :::* LISTEN 4628/sshd: /usr/sbi $ systemclt start sshd # 启动 ssh 服务 $ service ssh start Windows \u0026gt; 设置 \u0026gt; 应用 \u0026gt; 可选功能 \u0026gt; 添加可选功能\n选择 OpenSSH 服务端和 OpenSSH 服务端安装\n安装后在可选功能界面下方检查是否安装成功\nWindows 打开终端管理员, 设置 WSL IP 和 ssh 端口映射到 Windows 端口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 netsh interface portproxy add v4tov4 listenport=2222 listenaddress=0.0.0.0 connectport=2222 connectaddress=172.28.185.15 # listenport windows 端口 # listenaddress windows IP # connectport WSL 端口 # connectaddress WSL IP # 查看端口映射列表 netsh interface portproxy show all 侦听 ipv4: 连接到 ipv4: 地址 端口 地址 端口 --------------- ---------- --------------- ---------- 0.0.0.0 2222 172.28.185.15 2222 ","date":"2022-08-09T21:20:45Z","permalink":"https://facsert.github.io/p/linux-%E9%85%8D%E7%BD%AE/","title":"Linux 配置"},{"content":"系统 uname Unix name\n1 2 $ uname -a # 打印操作系统的所有信息 \u0026gt; Linux master 3.10.0-1160.81.1.el7.x86_64 #1 SMP Fri Dec 16 17:29:43 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux date 1 2 3 4 5 6 7 $ date # 现实系统时间 \u0026gt; Fri 07 Apr 2023 02:16:35 AM EDT $ date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34; # 格式化输出时间 \u0026gt; 2023-04-07 02:16:52 $ date -s \u0026#34;01:01:01 2022-08-09\u0026#34; # 设置时间 df disk free\n1 2 3 4 5 6 7 8 $ df # 显示系统磁盘占用信息, 默认以 KB 为单位 $ df -h # 容量数据以 MB 为单位 $ df -h # 容量信息智能添加单位 \u0026gt; Filesystem Size Used Avail Use% Mounted on \u0026gt; udev 3.9G 0 3.9G 0% /dev \u0026gt; tmpfs 796M 41M 755M 6% /run \u0026gt; /dev/sda1 58G 17G 39G 30% / du disk usage: 查看文件或文件夹占用大小\n1 2 3 4 5 6 7 8 9 10 11 12 $ du \u0026lt;arg\u0026gt; \u0026lt;file\u0026gt; # 显示目录占用空间大小 $ du -s \u0026lt;file\u0026gt; # --summarize 只显示总计占用 $ du -h \u0026lt;file\u0026gt; # --human-readable 添加单位 $ du * # 列出所有文件及大小 \u0026gt; 97764 go20.tar.gz \u0026gt; 4 host.txt \u0026gt; 24 mongo.tar.gz $ du -h # 智能显示单位 \u0026gt; 4.0K ./test \u0026gt; 834M . free 1 2 3 4 5 6 7 8 $ free # 显示系统内存占用(KB) $ free -m # 以 MB 为单位显示 $ free -g # 以 GB 为单位显示 $ free -h # 智能显示单位 total used free shared buff/cache available \u0026gt; Mem: 7.8Gi 1.2Gi 5.3Gi 41Mi 1.3Gi 6.3Gi \u0026gt; Swap: 974Mi 0B 974Mi ps process status: 进程状态\n1 2 3 4 5 6 $ ps \u0026lt;opt\u0026gt; # 显示系统进程状态 $ ps aux # 显示系统所有进程的详细信息 \u0026gt; USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND \u0026gt; root 1 0.0 0.1 104188 10472 ? Ss Apr02 0:03 /sbin/init \u0026gt; root 2 0.0 0.0 0 0 ? S Apr02 0:00 [kthreadd] \u0026gt; root 3 0.0 0.0 0 0 ? I\u0026lt; Apr02 0:00 [rcu_gp] systemctl systemctl control\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ systemctl \u0026lt;opt\u0026gt; \u0026lt;service\u0026gt; # 设置某项服务 $ systemctl start \u0026lt;service\u0026gt; # 启动nfs服务 $ systemctl enable \u0026lt;service\u0026gt; # 设置开机自启动 $ systemctl disable \u0026lt;service\u0026gt; # 停止开机自启动 $ systemctl status \u0026lt;service\u0026gt; # 查看服务当前状态 $ systemctl restart \u0026lt;service\u0026gt; # 重新启动某服务 $ systemctl list-units --type=service # 查看所有已启动的服务 $ systemctl statuc docker \u0026gt; ● docker.service - Docker Application Container Engine \u0026gt; Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) \u0026gt; Active: active (running) since Sun 2023-04-02 20:24:38 EDT; 4 days ago \u0026gt; Docs: https://docs.docker.com \u0026gt; Main PID: 704 (dockerd) \u0026gt; ...... netstat : network statistics 1 2 3 4 5 6 7 8 9 10 $ netstat \u0026lt;opt\u0026gt; # 显示网络端口信息 $ netstat -a # 显示所有网络端口信息 $ netstat -t # 显示 TCP 网络端口信息 $ netstat -u # 显示 UDP 网络端口信息 $ netstat -l # --listening 显示处于监听状态的端口 $ netstat -anlp | grep 22 \u0026gt; tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 577/sshd \u0026gt; tcp 0 0 10.0.2.15:22 10.0.2.2:61110 ESTABLISHED 19205/sshd: root@no \u0026gt; tcp6 0 0 :::22 :::* LISTEN 577/sshd ifconfig network interfaces configuring\n1 2 3 4 5 6 7 8 9 10 $ ifconfig # 显示网络接口配置和参数 \u0026gt; enp0s3: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 \u0026gt; inet 10.0.2.15 netmask 255.255.255.0 broadcast 10.0.2.255 \u0026gt; inet6 fe80::a00:27ff:fe2e:3801 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; \u0026gt; ether 08:00:27:2e:38:01 txqueuelen 1000 (Ethernet) \u0026gt; RX packets 1226712 bytes 239728472 (228.6 MiB) \u0026gt; RX errors 0 dropped 0 overruns 0 frame 0 \u0026gt; TX packets 857854 bytes 146145492 (139.3 MiB) \u0026gt; TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 \u0026gt; ...... kill 1 2 3 4 5 6 7 8 9 10 11 $ kill \u0026lt;opt\u0026gt; \u0026lt;pid\u0026gt; # 杀死进程 $ kill -9 \u0026lt;pid\u0026gt; # 强制杀死 \u0026lt;pid\u0026gt; 进程 $ killall \u0026lt;name\u0026gt; # 杀死所有名字为 \u0026lt;name\u0026gt; 进程 $ pkill -o \u0026lt;name\u0026gt; # 杀死 \u0026lt;name\u0026gt; 进程中进程号最小的 $ pkill -n \u0026lt;name\u0026gt; # 杀死 \u0026lt;name\u0026gt; 进程中进程号最大的 $ sleep 300 \u0026amp; # 后台执行 sleep 指令 \u0026gt; [1] 23287 # 系统返回后台的进程 pid $ kill -9 23287 # 根据 pip 杀死指定进程 \u0026gt; [1] + 23287 killed sleep 300 ","date":"2022-08-08T15:02:16Z","permalink":"https://facsert.github.io/p/linux-%E7%B3%BB%E7%BB%9F/","title":"Linux 系统"},{"content":"引申 字典是 python 非常常用的数据类型, 字典存取效率高且存取方便\n一个字典可以存储大量数据, 为了便于区分还可以层层分级, 多层嵌套\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 student = { \u0026#34;petter\u0026#34; : { \u0026#34;age\u0026#34;: 16, \u0026#34;hobby\u0026#34;: \u0026#34;swim\u0026#34;, }, \u0026#34;lily\u0026#34;: { \u0026#34;age\u0026#34;: 15, \u0026#34;hobby\u0026#34;: \u0026#34;sing\u0026#34;, } } student[\u0026#34;pttter\u0026#34;] # 字典取值 student[\u0026#34;steven\u0026#34;] = {\u0026#34;age\u0026#34;: 18} # 字典添加 key value student[\u0026#34;pttter\u0026#34;][\u0026#34;age\u0026#34;] = 17 # 字典多层数据赋值 (petter 必须存在) 对于多层字典存取比较麻烦\n插入值多层的数据的时候需要考虑上层是否存在\n1 2 3 student[\u0026#34;pttter\u0026#34;][\u0026#34;hobby\u0026#34;] # 取值时要确保上一层 petter 必须存在 student[\u0026#34;Bob\u0026#34;][\u0026#34;age\u0026#34;] = 18 # KeyError 报错, 需先定义上一层 Bob \u0026gt; KeyError: \u0026#39;bob\u0026#39; 能否简化深层字典的存取方式\n插入值的时候能否忽略层级问题, 自动生成多级数据\n字典扁平化 如何简单快捷的进行快速存取深层字典呢?\n能否将字典简化成单层结构, 字典内就是 key 和 value\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def flat_dict(dic, parent_key=\u0026#39;\u0026#39;, result={}): \u0026#39;\u0026#39;\u0026#39; Description: 原生字典多层 key 通过分隔符连接写入 flat 字典 Param dic dict: 原生字典 Param parent_key dict: 父字典的 key Return: None Attention: 任一层的字典 key value 都要保存 \u0026#39;\u0026#39;\u0026#39; for key, value in dic.items(): new_key = f\u0026#34;{parent_key}.{key}\u0026#34; if parent_key else key result[new_key] = value # 每深入一层, 就将 key 通过 . 并入 if isinstance(value, dict): flat_dict(value, new_key, result) # 对 value 时字典类型的值进行递归 flat = {} flat_dict(student, \u0026#39;\u0026#39;, flat) # 将扁平化键值对保存到 flat 中 \u0026gt; { \u0026#39;petter\u0026#39;: {\u0026#39;age\u0026#39;: 16, \u0026#39;hobby\u0026#39;: \u0026#39;swim\u0026#39;}, \u0026#39;petter.age\u0026#39;: 16, \u0026#39;petter.hobby\u0026#39;: \u0026#39;swim\u0026#39;, \u0026#39;lily\u0026#39;: {\u0026#39;age\u0026#39;: 15, \u0026#39;hobby\u0026#39;: \u0026#39;sing\u0026#39;}, \u0026#39;lily.age\u0026#39;: 15, \u0026#39;lily.hobby\u0026#39;: \u0026#39;sing\u0026#39; } flat[\u0026#39;lily.age\u0026#39;] # 15 可以通过多层 key 取值 为了保证任意层 key 都能取值, 所有层字典都需要扁平化, 因此增加了字典容量\n字典存取 能将字典扁平化后, 考虑如何存取\n魔改魔术方法 setitem 和 getitem 通过 [] 存取数据\n通过继承原始字典, 保留原生字典的属性和方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class FlatDict(dict): def __init__(self, *args, **kwargs): \u0026#39;\u0026#39;\u0026#39; Description: 初始化属性, flat(扁平化字典) separator(分隔符) Return: None Attention: 对象存一个原生字典和扁平化字典 \u0026#39;\u0026#39;\u0026#39; super().__init__(*args, **kwargs) super().update(*args, **kwargs) self.flat = {} # 新增属性 flat 保存扁平化字典 self.separator = \u0026#39;.\u0026#39; # 定义 key 连接符号 def __setitem__(self, key, value): pass def __getitem__(self, key): pass 写入 不带连接符号的 key 带连接符号的 key 使用字典原有赋值方法 解析 key 生成字典写入字典再扁平化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def __setitem__(self, key, value): \u0026#39;\u0026#39;\u0026#39; Description: 字典 [] 方式设置值 Param key str: 原生字典 Param value Any: 父字典的 key Return: None Attention: \u0026#39;\u0026#39;\u0026#39; if self.separator in key: self.update_dict(key, value) else: super().__setitem__(key, value) def update_dict(self, key, value): \u0026#39;\u0026#39;\u0026#39; Description: 解析 key, 将多层 key 逐层解析写入原生字典 Param key str: 字典 key, 多层 key 包含分隔符 Param value Any: 字典 value Return: None Attention: \u0026#39;\u0026#39;\u0026#39; dic = self keys = key.split(self.separator) for k in keys[:-1]: dic.setdefault(k, {}) if not isinstance(dic[k], dict): dic.update({k: {}}) dic = dic[k] dic[keys[-1]] = value self.flat_dict(self) 取出 先尝试从从本体取出, 失败后从扁平化字典取值\n1 2 3 4 5 6 7 8 9 10 11 def __getitem__(self, key): \u0026#39;\u0026#39;\u0026#39; Description: 字典 [] 获取值 Param key str: 字典 key, 允许使用多层 key Return Any: 字典 key 对应的 value Attention: \u0026#39;\u0026#39;\u0026#39; try: return super().__getitem__(key) except KeyError: return self.flat[key] 实现 __str__ 能直接格式化打印结果 添加自定义分隔符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 from json import dumps class FlatDict(dict): \u0026#34;\u0026#34;\u0026#34;扁平化字典\u0026#34;\u0026#34;\u0026#34; def __init__(self, *args, **kwargs): \u0026#39;\u0026#39;\u0026#39; Description: 初始化属性, flat(扁平化字典) separator(分隔符) Return: None Attention: 对象存一个原生字典和扁平化字典 \u0026#39;\u0026#39;\u0026#39; super().__init__(*args, **kwargs) super().update(*args, **kwargs) self.flat = {} self.separator = \u0026#39;.\u0026#39; def update_dict(self, key, value): \u0026#39;\u0026#39;\u0026#39; Description: 解析 key, 将多层 key 逐层解析写入原生字典 Param key str: 字典 key, 多层 key 包含分隔符 Param value Any: 字典 value Return: None Attention: \u0026#39;\u0026#39;\u0026#39; dic = self keys = key.split(self.separator) for k in keys[:-1]: dic.setdefault(k, {}) if not isinstance(dic[k], dict): dic.update({k: {}}) dic = dic[k] dic[keys[-1]] = value self.flat_dict(self) def flat_dict(self, dic, parent_key=\u0026#39;\u0026#39;): \u0026#39;\u0026#39;\u0026#39; Description: 原生字典多层 key 通过分隔符连接写入 flat 字典 Param dic dict: 原生字典 Param parent_key dict: 父字典的 key Return: None Attention: 任一层的字典 key value 都要保存 \u0026#39;\u0026#39;\u0026#39; for key, value in dic.items(): new_key = f\u0026#34;{parent_key}{self.separator}{key}\u0026#34; if parent_key else key self.flat[new_key] = value if isinstance(value, dict): self.flat_dict(value, new_key) def __setitem__(self, key, value): \u0026#39;\u0026#39;\u0026#39; Description: 字典 [] 方式设置值 Param key str: 原生字典 Param value Any: 父字典的 key Return: None Attention: \u0026#39;\u0026#39;\u0026#39; if self.separator in key: self.update_dict(key, value) else: super().__setitem__(key, value) def __getitem__(self, key): \u0026#39;\u0026#39;\u0026#39; Description: 字典 [] 获取值 Param key str: 字典 key, 允许使用多层 key Return Any: 字典 key 对应的 value Attention: \u0026#39;\u0026#39;\u0026#39; try: return super().__getitem__(key) except KeyError: return self.flat[key] def __delitem__(self, key): \u0026#39;\u0026#39;\u0026#39; Description: 字典删除 key-value Param key str: 字典 key, 不允许使用多层 key Return: None Attention: 只允许使用原生字典的 key \u0026#39;\u0026#39;\u0026#39; super().__delitem__(key) self.flat = {} self.flat_dict(self) def __len__(self): \u0026#39;\u0026#39;\u0026#39; Description: 获取原生字典长度 Return int: 字典长度 Attention: \u0026#39;\u0026#39;\u0026#39; return super().__len__() def update(self, *args, **kwargs): \u0026#39;\u0026#39;\u0026#39; Description: 更新字典 Return: None Attention: 用法与原生字典一致 \u0026#39;\u0026#39;\u0026#39; super().update(*args, **kwargs) self.flat = {} self.flat_dict(self) def __str__(self): \u0026#39;\u0026#39;\u0026#39; Description: json 格式原生字典 Return srt: 字典字符串 Attention: \u0026#39;\u0026#39;\u0026#39; return dumps(self, indent=4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 flat = FlatDict() flat.update({ \u0026#39;a\u0026#39;: { \u0026#39;b\u0026#39;: { \u0026#39;c\u0026#39;: 1 }, }, \u0026#39;e\u0026#39;:3, }) print(flat[\u0026#39;a.b\u0026#39;]) flat[\u0026#39;a.c.d\u0026#39;] = 2 print(flat) {\u0026#39;c\u0026#39;: 1} { \u0026#34;a\u0026#34;: { \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: 1 }, \u0026#34;c\u0026#34;: { \u0026#34;d\u0026#34;: 2 } }, \u0026#34;e\u0026#34;: 3 } ","date":"2022-07-24T19:05:13Z","permalink":"https://facsert.github.io/p/python-%E6%89%81%E5%B9%B3%E5%8C%96%E5%AD%97%E5%85%B8/","title":"Python 扁平化字典"},{"content":" 引申 开发的时候用到 logging 模块, 重新封装后发现使用有点麻烦\n多个模块都会用到该模块, logging 多次实例化会导致重复打印 使用前需要先获取对象, 无法直接使用其方法 只能实例化一次, 导致模块间使用需要频繁传递该对象 综上我在思考能否 import 后直接使用, 且不会多次实例化 通过查询资料了解到类方法和静态方法\n注: logging 模块可以统一输出格式, 打印在窗口并写入指定文件\n区别 方法类型 参数 装饰器 实例方法 self 无 类方法 cls @classmethod 静态方法 无 @staticmehtod 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class People: def obj_func(self): # 实例方法 print(f\u0026#39;obj function: {self} \\n\u0026#39;) @classmethod # 类方法 def class_func(cls): print(f\u0026#39;class function: {cls} \\n\u0026#39;) @staticmethod # 静态方法 def static_func(): print(\u0026#39;static function\u0026#39;) if __name__ == \u0026#39;__main\u0026#39;: facser = People() facser.obj_func() facser.class_func() facser.static_func() 1 2 3 4 5 \u0026gt; obj function: \u0026lt;__main__.People object at 0x000002673D477CA0\u0026gt; \u0026gt; \u0026gt; class function: \u0026lt;class \u0026#39;__main__.People\u0026#39;\u0026gt; \u0026gt; \u0026gt; static function 实例方法 最常见的方法, 方法的第一个参数为 self, 表示实例对象 通过 self 即可调用实例对象属性和方法\n实例可用范围 实例化对象可以使用哪些属性和方法 ?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class People: name = \u0026#39;kertory\u0026#39; # 定义类属性 name def obj_func(self): print(f\u0026#39;obj func: {self.name}\u0026#39;) # 打印对象属性 name @classmethod def class_func(cls): print(f\u0026#39;class func: {cls.name}\u0026#39;) # 打印类属性 name @staticmethod def static_func(): # 静态方法 print(\u0026#39;static function\u0026#39;) if __name__ == \u0026#39;__main\u0026#39;: facser = People() # 类实例化成对象 facser facser.obj_func() # facser 对象调用实例化方法 facser.class_func() # facser 对象调用类方法 1 2 3 \u0026gt; obj func: kertory # 实例方法打印 \u0026gt; class func: kertory # 类方法打印 \u0026gt; static function # 静态方法打印 实例化对象继承了类的属性 实例化对象是可以调用类方法和静态方法的\n类方法 类方法需要在定义时添加 @classmethod 装饰器, 参数第一个 cls 表示类本身\n类可用范围 类可以使用哪些属性和方法 ?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class People: name = \u0026#39;kertory\u0026#39; # 定义类属性 name def obj_func(self): print(f\u0026#39;obj func: {self.name}\u0026#39;) # 打印对象属性 name @classmethod def class_func(cls): print(f\u0026#39;class func: {cls.name}\u0026#39;) # 打印类属性 name @staticmethod def static_func(): # 静态方法 print(\u0026#39;static function\u0026#39;) if __name__ == \u0026#39;__main\u0026#39;: People.class_func() # 类调用类方法 People.static_func() # 类调用静态方法 People.obj_func() # 类调用实例方法 1 2 3 4 5 6 7 \u0026gt; class func: kertory # 成功执行类方法 \u0026gt; \u0026gt; static function # 成功执行静态方法 \u0026gt; Traceback (most recent call last): \u0026gt; File \u0026#34;E:\\文档\\Python\\python_class.py\u0026#34;, line 36, in \u0026lt;module\u0026gt; \u0026gt; People.obj_func() \u0026gt; TypeError: obj_func() missing 1 required positional argument: \u0026#39;self\u0026#39; 类可以使用类方法, 类属性和静态方法 类无法使用实例属性和实例方法, 后两者须实例化后才能使用\n静态方法 静态方法需要在定义时添加 @staticmethod 装饰器 静态方法无法调用类或者实例化对象的属性和方法, 仅是一个普通函数\n总结和实践 总结 静态方法属于类, 却无法使用类的属性和方法, 可以被类与对象使用 类方法可调用类属性, 类方法和静态方法, 可以被类与对象使用 实例化方法可调用类内所有属性方法, 但只可以被实例化对象使用 类型 可用范围 类 类方法, 类属性; 静态方法 对象 实例方法, 实例属性; 类方法, 类属性; 静态方法 logging 实践 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class logger: obj_log = None def info(cls, msg): # 定义类方法, 类可以直接使用 try: cls.obj_log.info(msg) # 正常执行, 表示 logger 类已创建 except Exception as _: cls.create_logger() # 执行失败则创建 logger 类后执行 cls.obj_log.info(msg) return msg def terminal_handle(cls): # 设置窗口打印格式 pass def file_handle(cls): # 设置文本写入打印格式 pass def create_logger(cls): # 自定义 logger 对象, 赋值给类属性 obj_log cls.obj_log = logging.getLogger() cls.terminal_handle() cls.file_handle() 通过类方法解决开头的难点\n仅 create 一次即可, 实例化对象保存在类属性 obj_log 中 无需实例化封装对象, import 后使用类方法即可 无需传递对象, 仅 import 即可使用 ","date":"2022-07-24T12:08:37Z","permalink":"https://facsert.github.io/p/python-%E7%B1%BB/","title":"Python 类"},{"content":"文本搜索 读取文本内容搜索或刷选符合条件的内容\ngrep global search regular expression and print out the line\n文本搜索和筛选\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ grep \u0026lt;patten\u0026gt; \u0026lt;file\u0026gt; # 从文件中筛选出符合模式的行, 可搜索多个文件 $ egrep \u0026lt;regex\u0026gt; \u0026lt;file\u0026gt; # 与 grep -E 类似 $ grep \u0026#34;3r\u0026#34; host.txt # grep 会显示所有包含 “3r” 的行 \u0026gt; 3rd $ cat host.txt | grep \u0026#34;3r\u0026#34; # 与上述命令效果一致 \u0026gt; 3rd $ grep -nE \u0026#34;[0-9]th\u0026#34; host.txt # 通过正则表达式匹配, 并显示行 \u0026gt; 4:4th \u0026gt; 5:5th $ cat host.txt | egrep -i \u0026#34;[0-9]TH\u0026#34; | grep -v 5 # 多次管道筛选行, egrep 与 grep -E 一致 \u0026gt; 4th # 通过正则忽略大小写筛选, 去除包含 5 的行 parameter meaning c --count 只显示匹配行的数量 E --extend-regexp 使用正则匹配 i --ignore-case 忽略大小写 o --only-matching 只显示匹配到内容, 同行其它内容不显示 n --line-number 同时显示行数 v --revert-match 反转查找, 显示不匹配的所有行 w --word-regexp 单词全匹配, 存在该单词的行, 不包含子字符串 x --line-regexp 行全匹配, 必须与行完全一致 wc Word count 文字计数\n1 2 3 4 5 6 $ wc -c # --bytes char 统计字符数量 $ wc -w # --words 统计单词数量 $ wc -l # --lines 统计行的数量 $ cat host.txt | wc -l # wc 是以行尾是否有换行符号判断为一行 \u0026gt; 4 host.txt # 实际有 5 行, 第 5 行结尾没有换行符号 文本编辑 xargs extended arguments: 文本格式转换与扩充\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ \u0026lt;command\u0026gt; | xargs \u0026lt;options\u0026gt; \u0026lt;command\u0026gt; # 处理左边命令的输出, 并作为右边命令的输入执行 $ echo \u0026#34;end\u0026#34; | xargs echo \u0026#34;start\u0026#34; # 将 \u0026#34;end\u0026#34; 传递给右边 echo 命令 \u0026gt; start end # 与 echo \u0026#34;start\u0026#34; \u0026#34;end\u0026#34; 一致 $ cat host.txt | xargs -n 3 # 读取文本内容, 修改格式, 每行 3 个字符串 \u0026gt; 1st 2nd 3rd # xargs 右边不填命令, 默认使用 echo \u0026gt; 4th 5th $ echo \u0026#34;1-2-3-4\u0026#34; | xagrs -d \u0026#39;-\u0026#39; -n 2 # 以 \u0026#39;-\u0026#39; 分割字符串, 分隔符号可以是单个字符,单个数字或单个字母 \u0026gt; 1 2 # 每行显示两个字符串 \u0026gt; 3 4 $ echo \u0026#34;1 2 3\u0026#34;| xargs -n 1 | xargs -i echo \u0026#34;line {} end\u0026#34; \u0026gt; line 1 end # xargs -n 1, 每行一个字符串, 将 1 行分割为 3 行 \u0026gt; line 2 end # -i 使用 {} 变量替换, 每一行内容替换掉 {} 执行 \u0026gt; line 3 end $ cat host.txt | xargs -I num sh -c \u0026#39;echo num start; echo num end\u0026#39; \u0026gt; 1st start # -I 设置变量 num(可自定义), 供后续多条命令执行 \u0026gt; 1st end # 执行两次 echo 命令, num 替换为 cat 的输出 \u0026gt; 2nd start \u0026gt; 2nd end sort 文本行排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ sort \u0026lt;file\u0026gt; # 按每行第首字符的 ACSII 码值顺序排序, 相同则往后一个一个比较 $ sort host.txt # 按每行字符 ACSII 逐个排序 \u0026gt; 128-1st-1 # 每行开头分别是 1 2 3, 按顺序排序 \u0026gt; 255-3rd-2 \u0026gt; 32-2nd-0 $ sort -n host.txt # 根据数值比较, 若是字母开头, 按单个字符的 ACSII 数值比较 \u0026gt; 32-2nd-0 # 每行开头数值是 32 128 255, 根据大小排序 \u0026gt; 128-1st-1 # 若开头是字符, 按单个字符 ACSII 数值排序 \u0026gt; 255-3rd-2 $ sort -t \u0026#34;-\u0026#34; -k 4 -n host.txt # 以 \u0026#39;-\u0026#39; 为分割符号, 取第 4 列按数值排序 \u0026gt; c-32-2nd-0 # -t \u0026#34;-\u0026#34; 以 - 符号分隔行 \u0026gt; b-128-1st-1 # -k 取第 4 列 \u0026gt; a-255-3rd-2 # -n 根据数值排序 $ sort -r \u0026lt;file\u0026gt; # --reverse 反向排序 $ sort -u \u0026lt;file\u0026gt; # --unique 不显示重复的行 tr transform 文本替换 压缩 删除\n1 2 3 4 5 6 7 8 9 10 11 12 $ tr \u0026lt;option\u0026gt; \u0026lt;parameter\u0026gt; # 文本替换, 删除, 合并相邻重复 $ cat host.txt | tr \u0026#39;a-z\u0026#39; \u0026#39;A-Z\u0026#39; | tr \u0026#34;-\u0026#34; \u0026#34;=\u0026#34; # 小写全替换为大写, - 替换为 = \u0026gt; 1ST=1 \u0026gt; 2ND=0 \u0026gt; 3RD=2 $ echo \u0026#34;aaccbbcc\u0026#34; | tr -s \u0026#39;ac\u0026#39; # -s 压缩多个连续 a 或多个连续 c 为 1 个 \u0026gt; acbbc # 仅限于单个字符重复, 且相邻重复才会生效 $ cat host.txt | xargs | tr -d \u0026#39;0-9\u0026#39; # 删除文件内所有数字 \u0026gt; st- nd- rd- # -d 后的内容逐一删除, 即删除 0 1 2 3 4 5 6 7 8 9 注: tr 替换或删除时把字符集看做多个字符进行操作 如 tr -d \u0026lsquo;abc\u0026rsquo; 表示删除文本中所有 a b c 字符\nsed stream editor 流式编辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ sed \u0026lt;option\u0026gt; \u0026lt;range\u0026gt; \u0026lt;model\u0026gt; \u0026lt;file\u0026gt; \u0026gt; option: 参数 \u0026gt; -i: sed 的修改结果写入文件 \u0026gt; -n: 输出结果, 与 p 合用只打印修改的行 \u0026gt; -e: 串联多个 sed 指令 \u0026gt; range: 行号或者正则筛选范围 \u0026gt; 行号: \u0026#39;3\u0026#39; 第三行; \u0026#39;2,5\u0026#39; 2到5行; \u0026#39;1~2\u0026#39; 奇数行; \u0026#39;2~2\u0026#39; 偶数行; \u0026gt; 正则: \u0026#39;/[0-9]/\u0026#39; 含有数字的行; \u0026#39;/1st/,/3rd/\u0026#39; 1st 行和 3rd 之间所有行 \u0026gt; model: 操作模式 \u0026gt; p: 打印模式 \u0026gt; d: 删除模式 \u0026gt; s: 替换模式 \u0026gt; \u0026lt;n\u0026gt;g: 与 s 替换模式合用, 标明替换次数 \u0026gt; a\\: 行尾追加 \u0026gt; i\\: 行首插入 select 筛选 1 2 3 4 5 6 7 8 9 10 $ sed \u0026lt;option\u0026gt; \u0026lt;line index\u0026gt; file # 根据行序号筛选行 $ sed \u0026lt;option\u0026gt; \u0026lt;regex\u0026gt; file # 根据关键字筛选行 $ sed -n \u0026#39;2,$p\u0026#39; host.txt # 截取第二行到最后一行 $ 代表最后一行 \u0026gt; 2nd-0 # 使用 -n 参数和 p 打印符合需求的行 \u0026gt; 3rd-2 $ sed -n \u0026#39;/[a-z]d/p\u0026#39; host.txt # 筛选包含 字母+d 的 行 \u0026gt; 2nd-0 \u0026gt; 3rd-2 delete 删除 1 2 3 4 5 6 7 8 9 10 $ sed \u0026lt;option\u0026gt; \u0026lt;line index\u0026gt; d file # 根据行序号筛选行 $ sed \u0026lt;option\u0026gt; \u0026lt;regex\u0026gt; d file # 根据关键字筛选行 $ sed \u0026#39;$d\u0026#39; host.txt # 删除最后一行 \u0026gt; 1st-1 # 显示删除后剩余的行, 文件保持不变 \u0026gt; 2nd-0 $ sed -i \u0026#39;/0$/d\u0026#39; host.txt # 删除以 0 为结尾的行 \u0026gt; 1st-1 # -i 显示删除后剩余的行, 并将修改写入文件 \u0026gt; 3rd-2 replace 替换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ sed \u0026lt;option\u0026gt; \u0026#39;s/\u0026lt;before\u0026gt;/\u0026lt;after\u0026gt;/\u0026lt;n\u0026gt;g\u0026#39; \u0026lt;file\u0026gt; # 逐行替换, s 替换模式; \u0026lt;n\u0026gt;g 替换 n 次, n 不填则全替换 $ echo \u0026#34;hi hi ha\u0026#34; | sed \u0026#39;s/hi/ha/g\u0026#39; # 将 hi 替换为 ha, n 未填, 全替换 \u0026gt; ha ha ha $ echo \u0026#34;hi hi ha\u0026#34; | sed \u0026#39;s:hi:ha:\u0026#39; # 将 hi 替换为 ha, 没有 g, 只替换一次 \u0026gt; ha hi ha # 定界符除了 / 也可以用 : , 或 | $ sed -i \u0026#39;s/-[0-3]/=end/1g\u0026#39; host.txt \u0026amp;\u0026amp; cat host.txt \u0026gt; 1st=end # -i, 不显示结果, 将修改写入文件 \u0026gt; 2nd=end # 支持正则表达式, 将 -1 -2 -3 都替换为 =end \u0026gt; 3rd=end # 结尾没有 g, 只替换一次 $ sed -n \u0026#39;s/nd\\|rd/th/gp\u0026#39; host.txt # -n 和 p 合用打印匹配的行 \u0026gt; 2th-0 # 将 nd 或 rd 替换为 th \u0026gt; 3th-2 $ sed \u0026#39;s/.d/(\u0026amp; or th)/g\u0026#39; host.txt # 使用 \u0026amp; 做变量替换 \u0026gt; 1st-1 \u0026gt; 2(nd or th)-0 \u0026gt; 3(rd or th)-2 add insert 追加 插入 1 2 3 4 5 6 7 8 9 10 11 12 13 $ sed \u0026lt;option\u0026gt; \u0026lt;regex\u0026gt; \u0026lt;a\\ i\\\u0026gt; \u0026lt;string\u0026gt; \u0026lt;file\u0026gt; # $ sed \u0026#39;/1st/a\\first line\u0026#39; host.txt # 在包含 1st 的行结尾添加 first line \u0026gt; 1st-1 # 行结尾是换行符, 追加内容在换行符后, 即下一行 \u0026gt; first line \u0026gt; 2nd-0 \u0026gt; 3rd-2 $ sed \u0026#39;/1st/1\\first line\u0026#39; host.txt # 在包含 1st 的行开头添加 first line \u0026gt; first line \u0026gt; 1st-1 \u0026gt; 2nd-0 \u0026gt; 3rd-2 awk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ awk \u0026#39;BEGIN{ commands } pattern{ commands } END{ commands }\u0026#39; \u0026lt;file\u0026gt; \u0026gt; BEGIN{ commands }: 操作文本前执行, 选填, 一般用于初始化变量 \u0026gt; pattern{ commands }: 行操作, 循环体, 对每行执行 \u0026gt; END{ commands }: 每次执行完行操作后执行, 选填, 一般用于打印行操作结果 $ awk \u0026#39;BEGIN{i=0} {i++} END{print i}\u0026#39; host.txt # 打印文本行 \u0026gt; 3 # 初始化 i, 每遍历一行, i + 1, 最后打印 i $ awk \u0026#39;{print $1, $NF, \u0026#34;index:\u0026#34;NR}\u0026#39; host.txt # 以空格为分隔,打印第 1 列, 最后一列及行序号 \u0026gt; 1st first index:1 # $0 表示整行, $\u0026lt;n\u0026gt; 表示第n列, 未指定分隔符号默认空格为分隔 \u0026gt; 2nd second index:2 # $NF 表示最后一列 $(NF-\u0026lt;N\u0026gt;) 倒数第 n 列 \u0026gt; 3rd third index:3 # NR 表示行序号, 不需要 $ $ num=2; awk -F \u0026#39;=\u0026#39; -v col=$num \u0026#39;{print \u0026#34;line: \u0026#34;NR \u0026#34; column \u0026#34; col\u0026#34;: \u0026#34; $col}\u0026#39; host.txt \u0026gt; line: 1 column 2: 1 # -F \u0026#34;=\u0026#34; 以 = 为分隔符号, 与 \u0026#39;BEGIN{ FS = \u0026#34;=\u0026#34; }\u0026#39; 效果一致 \u0026gt; line: 2 column 2: 0 # -v col=$num 从外部添加变量赋值给 col \u0026gt; line: 3 column 2: 2 # \u0026#34;\u0026#34; 内容打印, 变量自动替换, $\u0026lt;n\u0026gt; 取第 n 列 /dev/sda1 234G 191G 31G 87% / |-------| |--| |--| |--| |-| |--------| $1 $2 $3 $4 $5 $6 ($NF) NR: line index |-----------------------------------------| $0 select 筛选 1 2 3 4 5 6 7 8 9 10 11 12 13 $ awk \u0026lt;pattern\u0026gt; { command } $ awk \u0026#39;NR%2==1, $3 ~ /ir/ {print $0}\u0026#39; host.txt # 通过表达式筛选符合条件的行 \u0026gt; 1st 1 first # NR%2 == 1, 行序号为 2 的倍数余 1 , 即奇数行 \u0026gt; 3rd 2 third # $3 ~ /ir/ 即第 3 列包含 ir 字符串 $ awk \u0026#39;$1 !~ /nd/, /^[1-3]/ {print}\u0026#39; host.txt # 使用正则筛选行 \u0026gt; 1st 1 first # $1 !~ /nd/ 第 1 列不包含 nd 字符串 \u0026gt; 3rd 2 third # ^[1-3] 以数字 1 2 3 为行开头 $ awk \u0026#39;/sec/, /3rd/ {print}\u0026#39; host.txt # 通过子字符串截取两子字符之间所有的行 \u0026gt; 2nd 0 second # sec 在第 2 行 \u0026gt; 3rd 2 third # 3rd 在第 3 行 正则表达式 char meaning ^ 匹配输入字符串的开始位置, ^start 以字符串 start 开头 $ 匹配输入字符串的结束位置, $end 以字符串 end 开头 . 匹配除\u0026quot;\\n\u0026quot;之外的任何单个字符, . [] 匹配所包含的任意一个字符, [fac] 匹配 f a c 中任意单个字符, [a-z] 任意单个小写字母 [0-9] 任意单个数字 [^] 负值字符范围。匹配任何不在指定范围内的任意字符, [^fac] 匹配不包含 f a c 中任意单个字符 | 或匹配, 符号两边均可 [0-9]|[a-z] 匹配任意单个数字或小写字母 ？ 匹配前面的子表达式零次或一次, [0-9]? 匹配 0 个或 1 个数字 + 匹配前面的子表达式一次或多次, [A-Z]+ 匹配 1 个或多个大写字母 * 匹配前面的子表达式零次或多次, .*.txt 匹配任意单个字符出现0次或多次, 即表示任意以 .txt 结尾 {m} n是一个非负整数。匹配确定的n次。{3} 固定匹配 3 次 {m,n} m和n均为非负整数，其中n\u0026lt;=m。{1，3} 最少 1 次最多 3 次, {2,} 最少两次, {,4} 最多 4 次 () 匹配pattern并获取这一匹配, 将括号内匹配看成一个整体 （[0-9]=)* \u0026ldquo;数字=\u0026rdquo; 的格式出现任意次 正则表达式示例 匹配 IPV4 1 2 3 $ echo \u0026#34;127.0.0.1 \\n255.255.1 \\n0.0.0.0 \u0026#34; | egrep -o \u0026#34;([0-9]{1,3}\\.){3}[0-9]{1,3}\u0026#34; \u0026gt; 127.0.0.1 # -o 仅显示匹配内容, [0-9]{1,3} 任意数字出现 1 到 3 次 \u0026gt; 0.0.0.0 # ([0-9]{1,3}\\.){3} 匹配格式 3 次, . 经过转义仅表示 . 字符 ","date":"2022-07-19T15:02:16Z","permalink":"https://facsert.github.io/p/linux-%E6%96%87%E6%9C%AC/","title":"Linux 文本"},{"content":"特殊目录文件 位置 全称 说明 /etc Configuration Files 系统和软件的配置文件 /usr Unix Software Resource 应用程序默认安装位置 /dev Device Files 系统外围设备 /mnt Mount Directory 空目录, 用于临时挂载文件系统 /bin User Binaries 所有用户可用的基本命令 /home Home Directories 普通用户的主目录 /proc Process Information 虚拟文件系统, 以映射系统与进程在内存中的信息 位置 说明 /etc/environment 任意用户打开命令行加载, 系统环境变量 /etc/profile 任意用户打开命令行加载 /etc/bash.bashrc 任意用户打开命令行加载 ~/.profile 当前用户打开命令行时执行的文件 ~/.bashrc 当前用户打开 bash 命令行时执行的文件 /etc/apt/source.list (Ubuntu) apt 下载源文件 /var/cache/apt/archives/ (Ubuntu) apt 下载包安放位置 /ect/rc.d/rc.local 系统启动时执行的文件(centos, redhat) 文件查看 tree 以树状结构展示指定目录下的所有文件和子目录\n1 2 3 4 5 6 7 8 9 10 11 $ tree \u0026lt;path\u0026gt; # 显示目录的树状层级图 \u0026gt; Zip/ ├── targe.tar.gz └── main.sh \u0026gt; 0 directories, 2 files $ tree -a # 显示所有隐藏文件 $ tree -d # 仅显示目录不显示文件 $ tree -f # 树状图显示绝对路径 pwd dirs pwd: print working directory dir: directories\n显示当前绝对路径\n1 2 3 4 5 6 7 8 $ pwd # 显示当前路径 \u0026gt; /root/Desktop $ dirs # 显示当前路径 \u0026gt; /root/Desktop $ echo $PWD # 当前路径的全局变量 \u0026gt; /root/Desktop ls list files 显示当前路径下的文件及目录\n1 2 3 4 5 6 7 8 9 10 11 $ ls # 显示当前目录下所有文件及目录 $ ls -a # --all 额外显示隐藏文件及目录 $ ls -l # 使用长格式显示文集及目录详细信息 $ ls -R # --recursive 递归显示所有子目录 $ ls -S # sort 根据文件大小排序 $ ls -alS # 参数可无顺序合并, 结果按参数显示 \u0026gt; total 40 \u0026gt; drwxr-xr-x 10 root root 4096 Feb 27 20:44 . \u0026gt; drwx------ 14 root root 4096 Feb 27 20:35 .. \u0026gt; drwxr-xr-x 3 root root 4096 Oct 24 20:33 Blog file 显示文件信息\n1 2 3 $ file \u0026lt;file\u0026gt; # 显示文件类型 $ file main.py \u0026gt; main.py: Python script, ASCII text executable # 文件名, 类型, 编码类型 文件操作 cd change directory 切换工作路径\n1 2 3 4 5 6 7 $ cd \u0026lt;path\u0026gt; # 切换到 \u0026lt;paht\u0026gt; 目录 $ cd .. # 返回上级目录 $ cd - # 回到上次所有在目录 $ cd folder # 目录必须存在, 否则切换失败 \u0026gt; bash: cd: folder: No such file or directory mkdir make directories 创建目录\n1 2 3 4 5 6 7 8 9 10 $ mkdir \u0026lt;dir\u0026gt; # 创建目录 $ mkdir -v 1st 2nd 3rd # 创建多个文件夹, 并显示过程 \u0026gt; mkdir: created directory \u0026#39;1st\u0026#39; \u0026gt; mkdir: created directory \u0026#39;2nd\u0026#39; \u0026gt; mkdir: created directory \u0026#39;3rd\u0026#39; $ mkdir -p \u0026lt;path\u0026gt; # 创建多级目录,无论多级目录是否存在都会创建 $ mkdir -p 1st/2nd/3rd \u0026gt; mkdir: created directory \u0026#39;1st/2nd\u0026#39; \u0026gt; mkdir: created directory \u0026#39;1st/2nd/3rd\u0026#39; touch 创建文件\n1 2 3 4 $ touch \u0026lt;file\u0026gt; \u0026lt;file\u0026gt; # 文件不存在, 创建文件, 文件存在不创建, 可同时创建多个 $ touch 1st/main.sh # 创建时可以添加路径, 路径不存在会报错 \u0026gt; touch: cannot touch \u0026#39;1st/main.sh\u0026#39;: No such file or directory rm remove 删除文件\n1 2 3 4 5 $ rm \u0026lt;file\u0026gt; # 删除文件, 或删除文件夹 $ rm -f \u0026lt;file\u0026gt; # --force 强制删除文件, 不询问 $ rm -r \u0026lt;path\u0026gt; # -R, --recursive 递归删除, 删除文件夹及下所有文件 $ rmdir \u0026lt;path\u0026gt; # 删除空目录, 目录下有文件或文件夹报错 \u0026gt; rmdir: failed to remove \u0026#39;1st\u0026#39;: Directory not empty mv move: 移动文件或文件夹\n1 2 3 4 5 6 7 8 9 10 $ mv \u0026lt;file|dir\u0026gt; \u0026lt;file|dir\u0026gt; # 剪切复制并重新命名, 文件目录均可 $ mv \u0026lt;file\u0026gt; \u0026lt;path\u0026gt;/ # 保存文件名移动 $ mv -v # --verbose 显示过程, 打印原名及更改后名 $ mv -f # --force 强制移动, 存在同名则覆盖 $ mv -n # --no-clobber 存在同名文件则不移动 $ mv -bv main.sh master.sh # 文件重命名, 同名文件修改文件名令 mv 命令得以成功执行 \u0026gt; renamed \u0026#39;main.sh\u0026#39; -\u0026gt; \u0026#39;master.sh\u0026#39; (backup: \u0026#39;master.sh~\u0026#39;) \u0026gt; master.sh master.sh~ cp copy 复制文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ cp \u0026lt;file|dir\u0026gt; \u0026lt;file|dir\u0026gt; # 复制黏贴重命名 $ cp -v # --verbose 显示详细过程 $ cp -f # --force 强制复制, 存在同名直接覆盖 $ cp -r # -R, --recursive 递归复制 $ cp -b # backup 存在同名文件时, 目标文件改名 $ cp -l # --link 创建源文件的硬链接 $ cp -s # --symbolic-link 创建源文件的符号链接 $ cp -v mian.sh main.sh \u0026gt; \u0026#39;mian.sh\u0026#39; -\u0026gt; \u0026#39;main.sh\u0026#39; $ ln \u0026lt;source\u0026gt; \u0026lt;target\u0026gt; # 创建文件的硬链接 (使用绝对路径) $ ln -s \u0026lt;source\u0026gt; \u0026lt;target\u0026gt; # --symbolic 创建文件的符号链接 (使用绝对路径) 硬链接: 一个数据绑定两个名字, 两名字都删除才无法访问数据 符号链接: 数据的\u0026quot;软链接\u0026quot; \u0026ldquo;快捷方式\u0026rdquo;, 只是一个链接, 不含数据 文件查找 find 查询指定文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ find \u0026lt;path\u0026gt; \u0026lt;options\u0026gt; # 列出在 \u0026lt;path\u0026gt; 下符合参数的文件或目录(绝对路径) $ find . -name \u0026#34;*.txt\u0026#34; # 在 当前目录查找所有后缀为 .txt 的文件，模式匹配需要双括号 \u0026#34;\u0026#34; \u0026gt; ./a.txt \u0026gt; ./b.txt $ find . -path \u0026#34;*lib*\u0026#34; # 在当前目录所有绝对地址中含有 \u0026#39;lib\u0026#39; 的文件或目录 \u0026gt; ./temp \u0026gt; ./temp/a.txt \u0026gt; ./temp/b.txt $ find temp -regex \u0026#34;.*\\.txt$\u0026#34; # 当前目录的 temp 文件夹下符合正则表达式的文件 \u0026gt; temp/a.txt # .* 任意字符任意次, \\.txt$ 以 .txt 结尾 \u0026gt; temp/b.txt $ find \u0026lt;dir\u0026gt; \u0026lt;options\u0026gt; -exec \u0026lt;command\u0026gt; {} \\; # 对查找到的文件进行操作 $ find . -name \u0026#34;*.sh\u0026#34; -exec rm {} \\; # 删除当前目录下后缀为 .sh 文件 $ find . -name \u0026#34;*.py\u0026#34; -exec mv {} /root \\; # 将当前目录下后缀为 .py 文件移动到 /root $ find . -type f -exec sh -c \u0026#39;echo \u0026gt;{}\u0026#39; \\; # 清空当前目录下所有文件内容 文件内容 cat concatenate 读取文件内容\n1 2 3 4 5 $ cat \u0026lt;file\u0026gt; # 读取并打印文件内容 $ cat -n \u0026lt;file\u0026gt; # 打印文件内容并添加行数 \u0026gt; 1 1st \u0026gt; 2 2nd \u0026gt; 3 3rd head tail 读取文件部分内容\n1 2 3 4 5 6 7 8 9 10 11 $ head \u0026lt;file\u0026gt; # 显示文件的前 10 行 $ head -n 5 \u0026lt;file\u0026gt; # --lines 显示文件前 5 行 $ head -c 20 \u0026lt;file\u0026gt; # --bytes 显示文件前 20 个字符 $ tail \u0026lt;file\u0026gt; # 显示文件的后 10 行 $ tail -n 5 \u0026lt;file\u0026gt; # --lines 显示文件后 5 行 $ tail -c 20 \u0026lt;file\u0026gt; # --bytes 显示文件最后 20 个字符 $ head -c 5 log \u0026gt; 1st \u0026gt; 2 ","date":"2022-07-18T22:49:44Z","permalink":"https://facsert.github.io/p/linux-%E6%96%87%E4%BB%B6/","title":"Linux 文件"},{"content":"linux 命令\n帮助信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ man \u0026lt;command\u0026gt; # man (manual) 帮助手册, 查看命令的帮助手册 $ man -f \u0026lt;command\u0026gt; # 显示命令的简短描述 $ man -f date \u0026gt; date (1) - print or set the system date and time $ whatis \u0026lt;command\u0026gt; # 显示命令的简短描述, 等同于 man -f \u0026lt;command\u0026gt; $ whatis date \u0026gt; date (1) - print or set the system date and time $ \u0026lt;command\u0026gt; -h/--help # 命令使用 -h/--help 参数 $ date -h $ date --help \u0026gt; Usage: date [OPTION]... [+FORMAT] \u0026gt; or: date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]] \u0026gt; Display the current time in the given FORMAT, or set the system date. 文件与路径 1 2 3 4 5 6 7 8 $ pwd # 查看当前目录 \u0026gt; /root/Desktop $ ls # 查看当前目录下的文件及文件夹 \u0026gt; source.sh target.tar.gz $ cd \u0026lt;path\u0026gt; # 切换到 path 目录(无返回值), path 不存在则报错 ~/Desktop/Zip$ # 命令行 $ 左边即为当前目录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ cp \u0026lt;source\u0026gt; \u0026lt;destination\u0026gt; # 文件复制 $ mv \u0026lt;source\u0026gt; \u0026lt;destination\u0026gt; # 文件移动或重命名 $ rm \u0026lt;file\u0026gt; # 删除文件 $ mkdir \u0026lt;path\u0026gt; # 创建文件夹 $ touch \u0026lt;file\u0026gt; # 创建文件 $ cat \u0026lt;file\u0026gt; # 查看文件内容 $ touch learn.log # 创建文件 learn.log $ mkdir seeds # 创建文件夹 seeds $ cp learn.log seeds/ # learn.log 复制到 seeds 文件夹下 $ rm learn.log # 删除当前目录下的 learn.log $ mv seeds/learn.log study.log # 将 seeds 下的 learn.log 移动到当前目录并重命名 $ rm -r seeds # 删除 seeds 文件夹及文件夹下的所有文件 \u0026gt; \u0026#39;learn.log\u0026#39; -\u0026gt; create \u0026gt; \u0026#39;seed/\u0026#39; -\u0026gt; create \u0026gt; \u0026#39;learn.log\u0026#39; -\u0026gt; \u0026#39;seed/learn.log\u0026#39; \u0026gt; \u0026#39;learn.log\u0026#39; -\u0026gt; delete \u0026gt; \u0026#39;seeds/learn.log\u0026#39; -\u0026gt; \u0026#39;study.log\u0026#39; \u0026gt; \u0026#39;seed/\u0026#39; -\u0026gt; delete 查看执行过命令 1 2 3 4 5 6 7 8 9 $ history # 查看执行的命令历史 \u0026gt; 1 ls \u0026gt; 2 date $ !! # 执行上一条命令 $ !\u0026lt;command key\u0026gt; + enter # 通过命令关键字和 enter 执行上一个包含关键字的命令 $ control + r + \u0026lt;command key\u0026gt; # 快捷键进入历史列表, 通过关键字查找, enter 执行命令 \u0026gt; (reverse-i-search)`echo $\u0026#39;: echo $PWD # `echo $\u0026#39; 是输入关键字, : 后为匹配的命令, 方向键选择命令但不执行 全局变量 全局变量是在整个操作系统中都可用的变量，其值可以在任何地方被访问和修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ echo $HOME # 当前用户名 \u0026gt; root $ echo $PATH # 执行命令时所搜寻的路径列表, 以 : 分隔(环境变量设置路径) \u0026gt; /usr/local/sbin:/usr/local/bin:/usr/bin $ echo $SHELL # 当前使用的 shell \u0026gt; /bin/zsh $ echo $PWD # 当前绝对路径 \u0026gt; /root/Desktop/ $ echo $RANDOM # 生成随机数字 \u0026gt; 2166 修改 shell 启动文件(每次打开命令行均会执行)以永久设置环境变量, 使用 export 添加环境变量\n1 2 3 4 5 export \u0026lt;variable name\u0026gt;=\u0026lt;value\u0026gt; # 使用 export 临时修改环境变量, 执行的命令窗口关闭即失效 export PATH=$PATH:/home/facsert # 将 /home/facsert 临时加入环境目录 export LEARN=TRUE # 自定义新的环境变量, 脚本间可以通过自定义环境变量通信 export PATH=$PATH:/home/facsert # 将命令写入 shell 启动文件(每次启动 shell 均会执行文件上命令) source ~/.bashrc # 重新加载 shell 启动文件(~/.bashrc, ~/.zshrc ) bash 执行脚本: 新建子 shell 执行脚本, 脚本中的 export 的变量只在子 shell 生效, 脚本结束变量失效 source 执行脚本: 脚本中的 export 变量加载入当前终端, 脚本结束仍然生效, 当前终端关闭后失效\n1 2 3 4 5 6 7 8 $ echo \u0026#39;export linux=\u0026#34;bash\u0026#34;\u0026#39; \u0026gt; bash.sh # 生成脚本 bash.sh $ echo \u0026#39;export linux=\u0026#34;source\u0026#34;\u0026#39; \u0026gt; source.sh # 生成脚本 source.sh $ bash bash.sh \u0026amp;\u0026amp; echo \u0026#34;linux: $linux\u0026#34; # 使用 bash 添加 linux 变量 \u0026gt; linux: # 脚本结束, 变量失效 $ source source.sh \u0026amp;\u0026amp; echo \u0026#34;linux: $linux\u0026#34; # 使用 source 执行脚本 \u0026gt; linux: source shell # 脚本结束, 变量仍然生效 系统相关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ shutdown -h now # 关机 $ shutdown -r now # 重启 $ date # 系统时间 \u0026gt; Sat Feb 25 20:34:10 CST 2023 $ unmae -a # 查看系统内核信息 \u0026gt; inux facser 5.15.79.1-microsoft-standard-WSL2 #1 SMP Wed Nov 23 01:01:46 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux $ ps -ef # 查看当前正在运行的所有进程 \u0026gt; UID PID PPID C STIME TTY TIME CMD \u0026gt; root 1399 71 0 19:08 pts/4 00:00:00 /bin/zsh -i \u0026gt; root 9481 490 0 20:24 pts/4 00:00:00 bash -x a.sh $ kill \u0026lt;pid\u0026gt; # 根据 pid 关掉指定进程 $ kill 9481 \u0026gt; [1] + 9481 terminated bash -x a.sh 用户 启用 root 用户 1 2 3 4 5 6 7 8 9 $ sudo passwd root \u0026gt; Enter new UNIX password: # 设置 root 用户密码(输入时密码不可见) \u0026gt; Retype new UNIX password: # 重复输入 root 密码 \u0026gt; passwd: password updated successfully # 设置成功 facser@master:~/Desktop$ su root # 切换 root 用户 (用户名@hostname:当前路径) root@master:~/Desktop# exit # 退出 root, 普通用户 $ 开头, root 用户 # 开头 $ su \u0026lt;user\u0026gt; # 切换用户 创建用户 1 2 3 4 5 6 7 8 9 $ useradd -m \u0026lt;username\u0026gt; # 创建用户, 并在 /home 生成用户目录 $ useradd -l \u0026lt;oldName\u0026gt; \u0026lt;newName\u0026gt; # 更换用户名称 $ passwd \u0026lt;username\u0026gt; # 用户添加密码 \u0026gt; New password: # 输入密码, 密码不显示 \u0026gt; Retype new password: # 重复输入密码, 密码不显示 $ userdel -r \u0026lt;username\u0026gt; # 删除用户 \u0026gt; no crontab for facsert sudo 免密码\n1 2 3 4 5 $ sudo vi /etc/sudoers # 编辑配置文件 \u0026gt; %sudo ALL=(ALL:ALL) ALL # 找到这一栏, 建议注释掉复制一行修改 \u0026gt; %sudo ALL=(ALL:ALL) NOPASSWD:ALL # 修改后, 强制保存退出 \u0026gt; \u0026lt;username\u0026gt; ALL=(ALL) NOPASSWD:ALL 注: 该文件必须强制写入, 不能修改文件权限, 否则报错\n通配符号 ？ 任意单个字符 1 2 3 4 5 6 7 $ touch ab a bc abc # 生成 ab a ba abc 4 个文件 $ ls ?b # ? 可以指代任意单个字符 \u0026gt; ab $ ls b? \u0026gt; bc * 任意多个字符 1 2 3 4 5 6 7 $ touch ab a bc abc # 生成 ab a ba abc 4 个文件 $ ls * # * 可以指代任意多个字符 \u0026gt; a ab abc bc $ ls a* \u0026gt; a ab abc ** 任意多级目录 1 2 3 4 $ cat /etc/**/word # /etc/ 文件夹下所有 word 文件 $ ls learn/**/*.md # 显示 learn 目录下所有 markdown 文件 \u0026gt; a.md b.md c.md [] 匹配范围 1 2 3 4 $ touch aa ab ac aab # 生成 ab a ba abc 4 个文件 $ ls a[ab] # 匹配 [] 内任意一个字符 \u0026gt; aa ab 特殊符号 输出重定向 输出重定向 输出重定向追加写入 输入重定向 读取标准输入直至分界符号 \u0026gt; \u0026gt;\u0026gt; \u0026lt; \u0026lt;\u0026lt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ \u0026lt;command\u0026gt; \u0026gt; \u0026lt;file\u0026gt; # 将命令返回值覆盖写入文件(原文件清空后写入) $ date \u0026gt; file.log # 将 date 命令返回值写入 file.log 文件, 命令行不显示结果 \u0026gt; Sat Feb 25 20:39:56 CST 2023 $ \u0026lt;command\u0026gt; \u0026gt;\u0026gt; \u0026lt;file\u0026gt; # 将输出追加写入文件(原文件内容保留) $ date \u0026gt;\u0026gt; file.log # 将 date 命令返回值追加写入 file.log 内容结尾, 命令行不显示结果 \u0026gt; Sat Feb 25 20:39:56 CST 2023 \u0026gt; Sat Feb 25 20:40:51 CST 2023 $ \u0026lt;command\u0026gt; \u0026lt; \u0026lt;file\u0026gt; # 将文件内容重定向为标准输入 $ cat \u0026lt; file.log # 读取 file.log 并打印 \u0026gt; Sat Feb 25 20:39:56 CST 2023 \u0026gt; Sat Feb 25 20:40:51 CST 2023 $ touch $(\u0026lt; fileName.log) # 根据文件内的文件列表生成文件 $ cat \u0026lt;\u0026lt; EOF # 实现多行输入, 分界符号 EOF 可自定义 \u0026gt; line \u0026gt; line \u0026gt; EOF \u0026amp;1: 标准输出, 命令行输出, 能直接重定向至文件\n\u0026amp;2: 标准错误, 命令执行错误输出, 需要将错误重定向至标准输出再指向文件\n/dev/null: 空, 指代垃圾桶或回收站\n1 2 3 4 5 6 7 8 $ mian # 错误命令,显示错误输出 \u0026gt; Command \u0026#39;mian\u0026#39; not found $ data 2\u0026gt;/dev/null # 错误命令, 错误输出重定向至回收站, 不显示错误 $ date 2\u0026gt;/dev/null # 正确命令, 标准输出重定向至回收站, 不显示返回值 $ data 2 \u0026gt; date.log # 命令行显示错误, 文件不显示, 错误输出无法直接重定向文件 $ data \u0026gt; date.log 2\u0026gt;\u0026amp;1 # 命令行不显示错误, 文件内显示, 错误输出重定向至文件 单词缩写 缩写 全称 翻译 a all 全部 b backup 备份 c count 计数 d directory 文件 f force 强制 h help 帮助 i interactive 交互的 l long 长格式的 r / R recursive 递归 s / S sort/size 排序/大小 t time 时间 u user 用户 v version / verbose 版本/详细的 符号 符号 含义 \u0026gt; 输出重定向, 覆盖 \u0026gt;\u0026gt; 输出重定向, 追加 \u0026amp; 程序放入后台执行 # 注释 \u0026amp;\u0026amp; 且, 左边成功才执行右边 正则表达式 符号 模式 ^ 锚定行首 $ 锚定行尾 () 捆绑成一个整体 . 任意一个字符 ? 前面字符或模式 0 或 1 次 {m} 前面字符或模式 m 次 {m, n} 前面字符或模式次数在 m n 之间 + 前面字符或模式 1 次或多次 * 前面字符或模式任意次 [] 括号范围内均可 [^] 括号范围之外均可 ","date":"2022-07-18T15:02:16Z","permalink":"https://facsert.github.io/p/linux-%E5%9F%BA%E7%A1%80/","title":"Linux 基础"},{"content":"Download and Update nodejs 官网\nnodejs 通过 n 模块更新或切换版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ node -v # node 版本 \u0026gt; v18.15.0 $ npm cache clean -f # 清除nodejs的cache： $ npm install -g n # 使用npm全局安装n模块 $ npm view node versions # node所有版本 $ n latest # 升级到最新版本 $ n stable # 升级到最新稳定版本 $ n 18.15.0 # 升级到 18.15.0 版本, 某个具体版本号 $ npm -v # npm 版本, node 的包管理器 \u0026gt; 9.5.0 $ npm install npm@latest -g # npm 升级到最新版 $ npm install npm@xx -g # npm 升级到指定版本 $ npm version # 查看当前 npm 版本详情 $ npm view npm version # 查看 npm 最新版本 $ npm view npm versions # 查看 npm 所有版本 $ npm list # 已安装插件清单 npm 配置 npm 可用更换默认模块安装位置和缓存位置 npm 可更换下载源为国内源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ npm config set prefix \u0026lt;path\u0026gt; # 更换全局模块安装位置 $ npm get prefix # 查看 npm 安装全局模块的位置 \u0026gt; /usr/local $ npm config set cache \u0026lt;path\u0026gt; # 更换 npm 缓存位置 $ npm get cache # 查看 npm 缓存存放的位置 \u0026gt; /Users/facsert/.npm $ npm install nrm -g # 使用资源切换工具 nrm 切换下载源 $ nrm ls # 列出可用的下载源 $ nrm use taobao # 使用 taobao 源 $ npm config get registry # 查看当前 npm 下载源 \u0026gt; https://registry.npmjs.org/ # 官方 npm 下载源 $ npm config set registry \u0026lt;source\u0026gt; # 命令切换 npm 下载源 npm 全局安装, 存放在全局模块位置, 所有项目生效 npm 本地安装, 在当前目录 node_modules 文件夹下, 仅目录下项目生效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ npm init # 初始化项目, 生产 package.json 记录安装的模块及版本 $ npm install vue --save # 更新 package.json 中 vue 版本的版本信息 $ npm install # 目录下存在 package.json 会自动根据文件下载依赖包 $ npm list # 查看当前项目安装的模块 $ npm list -g # 查看全局安装的模块 /usr/local/lib ├── corepack@0.17.1 ├── n@9.0.1 ├── npm@9.6.2 └── yarn@1.22.19 $ npm install \u0026lt;package\u0026gt; # 本地安装模块 $ npm install \u0026lt;package\u0026gt; -g # 全局安装模块 $ npm uninstall \u0026lt;package\u0026gt; # 卸载本地安装的模块 $ npm uninstall \u0026lt;package\u0026gt; -g # 卸载全局安装的模块 yarn 配置 1 2 3 4 5 6 7 8 9 10 11 12 $ npm install yarn -g # npm 全局安装 yarn $ yarn config set global-folder \u0026lt;path\u0026gt; # 设置全局安装目录 $ yarn config set cache-folder \u0026lt;path\u0026gt; # 设置全局缓存目录 $ yarn global add yrm # 安装 yrm 以切换下载源 $ yrm ls # 列出所有下载源 $ yrm use taobao # 使用 taobao 源 $ yarn config get registry # 查看当前 yarn 下载源 \u0026gt; https://registry.yarnpkg.com # yarn 官方默认源 $ yarn config set registry \u0026lt;source\u0026gt; # 命令更换 yarn 下载源 yarn 的使用与 npm 类似\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ yarn init # yarn 初始化项目, 生成 package.json $ yarn install # 目录下有 package.json 自动下载文件内的包 $ yarn global add \u0026lt;package\u0026gt; # 全局安装工具包 $ yarn add \u0026lt;package\u0026gt; # 本地安装包 $ yarn global remove \u0026lt;package\u0026gt; # 卸载全局包 $ yarn remove \u0026lt;package\u0026gt; # 卸载项目下的包 $ yarn upgrade \u0026lt;package\u0026gt; # 更新某个包 $ yarn list # 显示本地安装的所有包 $ yarn global list # 显示全局安装的所有包 \u0026gt; yarn global v1.22.19 \u0026gt; - yrm $ yarn info \u0026lt;package\u0026gt; # 查看包的信息 ","date":"2022-07-18T15:02:16Z","permalink":"https://facsert.github.io/p/node-%E9%85%8D%E7%BD%AE/","title":"Node 配置"},{"content":" 风格 命名 注释 风格 空格 对齐 换行 一致性 使用空格, 对齐, 换行的规则形成代码风格\n空格 使用空格使运算语句更清晰, 分隔多个数据, 参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 4 + 2 # 6 二元运算 2 ** 3 # 8 指数运算 love = True # 赋值 love is True # True 逻辑判断 not love # False 非运算 love \u0026gt; (not love) # True 比较运算 love and love # True 逻辑运算 (1, 2, 3) # 数据之间空格区分 {\u0026#39;name\u0026#39;: \u0026#39;petter\u0026#39;} # 键值对区分 key value func(msg=\u0026#39;hello\u0026#39;, name=\u0026#39;petter\u0026#39;) # 参数之间空格区分 1 2 3 4 !true // false 非运算 一元运算 ~2 // -3 按位取反 [1, 2, 3] // 逗号前不需要空格 {\u0026#39;key\u0026#39;: \u0026#39;value\u0026#39;} // 括号开头和结尾无需空格 对齐 通过空格与缩进区分代码所属区域\n1 2 3 4 5 6 7 if (count) { while (count--) { // while 循环在 if 条件下 console.log(count); // 打印操作在 while 循环内 }; console.log(\u0026#39;while cycle over\u0026#39;); // 循环结束后打印结果 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 run_long_name_function( cycle=\u0026#39;1\u0026#39;, # 函数名较长和参数过多, 换行需要缩进 step=\u0026#39;reset\u0026#39;, log=\u0026#39;pass\u0026#39;, time=133 ) { \u0026#39;SIT\u0026#39;: { \u0026#39;TA\u0026#39;: { ... } \u0026#39;BMC\u0026#39;: { ... }, \u0026#39;BIOS\u0026#39;: { ... }, \u0026#39;SV\u0026#39;: { ... }, } } 相同的内容对齐后更容易发现差异, 代码整体更加美观整洁\n1 2 3 4 http.post(username=\u0026#39;facser\u0026#39;, email=\u0026#39;facser@example.com\u0026#39;, phone=\u0026#39;12345678\u0026#39;) http.post(username=\u0026#39;kertory\u0026#39;, email=\u0026#39;kertory@example.com\u0026#39;, phone=\u0026#39;12345678\u0026#39;) http.post(username=\u0026#39;victory\u0026#39;, email=\u0026#39;victory@example.com\u0026#39;, phone=\u0026#39;12345678\u0026#39;) http.post(username=\u0026#39;petter\u0026#39;, email=\u0026#39;petter@example.com\u0026#39;, phone=\u0026#39;12345678\u0026#39;) 空行 时用空行分隔无关的代码, 使相关的代码形成代码块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def connect_sut(): title(\u0026#39;Connect SUT Test\u0026#39;, 3) if not ping(config[\u0026#39;BMC_host\u0026#39;], count=5, delay=5): display(f\u0026#34;BMC host {config[\u0026#39;BMC_host\u0026#39;]} connect failed \u0026#34;, False) exit() if not ping(config[\u0026#39;OS_host\u0026#39;], count=5, delay=5): display(f\u0026#34;OS host {config[\u0026#39;OS_host\u0026#39;]} connect failed \u0026#34;, False) exit() if not exists(config[\u0026#39;Tool_dir\u0026#39;]): display(f\u0026#34;{config[\u0026#39;Tool_dir\u0026#39;]} not exist \u0026#34;, False) exit() try: run(config[\u0026#39;Get_bios_attribute\u0026#39;], code=True) except RuntimeError as _: display(\u0026#39;Get BIOS option failed \u0026#39;, False) exit() display(\u0026#39;Connect SUT successfully\u0026#39;) 一致性 在一个项目里只使用一种代码风格\n命名法(驼峰法, 蛇形命名)不要混用, 相似的问题尽量使用同一种解决方式 相似的结构或处理方式, 代码格式尽量保持一致 命名 准确 突出重点 简洁 一致性 命名目地: 把信息放入名字里\n变量命名: 名词 形容词 函数命名: 动词 名词 (形容词)\n1 2 3 errTestMsg # 驼峰命名 err_test_msg # 蛇形命名, 下划线 _ 区分断点 准确 突出重点 使用 准确 具体 单一的词\n常用动词\n正向语义命名\n1 2 3 4 5 test_pass = True # 推荐 test_fail = False # 不推荐 able = True # 值与语义对应 unable = False # 双重否定表示肯定 通过 前缀 后缀 突出重点 强调或者注意的内容放在最后\n1 2 3 4 5 6 7 8 is_xx # 是不是 should_xx # 是否应该 has_xx # 有没有 can_xx # 能不能 max_xx # 最大的 min_xx # 最小的 avg_xx # 平均的 1 2 3 4 5 6 7 time_secs = 8 # 时间变量添加单位 size_mb = 2 # 添加单位 mb length_str = \u0026#39;5\u0026#39; # 添加值类型后缀 book_json = {\u0026#39;code\u0026#39;: {...}} # 添加值类型后缀 apple_red # 强调 apple 的颜色 red_apple # 强调 apple 个体 长度 使用常用的单词缩写\n省略无用的内容\n在小的作用域内可以使用简短的变量名\n1 2 3 4 5 6 7 8 9 def get_basic_manager_controller_information(): ali_basic_manager_controller_username = \u0026#39;admin\u0026#39; ali_basic_manager_controller_password = \u0026#39;admin\u0026#39; ali_basic_manager_controller_information_command = \u0026#39;ipmitool mc info\u0026#39; def get_bmc_info(): username = \u0026#39;admin\u0026#39; password = \u0026#39;admin\u0026#39; info_cmd = \u0026#39;ipmitool mc info\u0026#39; 常见单词缩写\n一致性 项目中表示同样的值或类似的值, 命名方式应该一致\n1 2 3 4 5 6 7 8 9 def title(string=\u0026#39;title\u0026#39;, level=3, length=30): pass def wait(delay=1, show=True, length=50): pass def ping(host, count=3, delay=10, show=True): pass 注释 代码比注释更重要 注释应强调使用规范和缺陷\n代码比注释更重要 注释是代码的补充, 先写好代码, 再使用注释引导读者理解代码 无需用注释解释能从代码迅速推断的内容, 避免无效注释\n强调使用规范和缺陷 函数和类的注释要表明参数类型, 使用方式 表明对可能出现的问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def title(string=\u0026#39;title\u0026#39;, level=3, length=30): \u0026#34;\u0026#34;\u0026#34;根据 level 等级打印不同样式的标题 Args: string (str, optional): 标题内容. Defaults to \u0026#39;title\u0026#39;. level (int, optional): 标题等级 (0, 1, 2, 3). Defaults to 3. length (int, optional): 标题一端符号的数量. Defaults to 30. Returns: None: 无返回值 Attention: 标题有4个等级, 与符号对应关系是 0: \u0026#39;##### title #####\u0026#39; 1: \u0026#39;===== title =====\u0026#39; 2: \u0026#39;***** title *****\u0026#39; 3: \u0026#39;----- title -----\u0026#39; \u0026#34;\u0026#34;\u0026#34; pass 附录 常用动词 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 添加/插入 add, append, insert, 创建/初始化 create, initialize, 加载/选择 load, pick, select 删除/销毁 delete, remove, destroy, drop 打开/启动 open, start 关闭/停止 close, stop 获取/读取 get, fetch, acquire, read, 查找/查询 search, find, query 设置/重置 set, reset 放入/写入 put, write, 释放/刷新 release, refresh 发送/推送 send, push 接收/拉取 receive, pull 提交/取消 submit, cancel 收集/采集 collect, 提取/解析 sub, extract, parse 编码/解码 encode, decode 填充/压缩 fill, pack, compress 清空/解压 flush, clear, unpack, decompress 增加/减少 increase, decrease, reduce 分隔/拼接 split, join, concat 过滤/校验/检测 filter, valid, check 单词缩写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 addition add 加 subtraction sub 减 multiplication mul 乘法 division div 除法 hexadecimal hex 十六进制 array arr 数组, 集合 list/Sequence lst/seq 列表 dictionary dict 字典 character char 字符 string str 字符串 text txt 文本 number num 数量, 编号 image img 图像 length len 长度 summation sum 和 average avg 平均 maximum max 最大值 minimum min 最小值 middle mid 中值 source src 源头 address addr 地址 previous pre 前一个 current cur 当前的 initalize init 初始化 database db 数据库 administrator adm 管理员 password pwd 密码 user usr 用户 directory dir 目录 document doc 文档 library lib 库 function func 函数 object obj 对象 argument arg 实参 variable var 变量 parameter param 参数(形参) execute exec 执行 command cmd 命令 configuration config 配置 ","date":"2022-07-13T21:27:49Z","permalink":"https://facsert.github.io/p/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/","title":"代码格式"},{"content":"介绍 远程仓库是托管在网上的项目版本库, 需要在代码平台上创建, 常见的如\nGithub Gitlab Gitee 可以通过两种方式添加远程仓库\n1 2 3 4 5 6 7 $ git clone \u0026lt;Repository url\u0026gt; # 克隆远端仓库到本地, 自动绑定链接对应的仓库 $ git remote -v # 查看本地仓库关联的所有远端仓库 \u0026gt; origin git@github.com:facser/Learning.git (fetch) \u0026gt; origin git@github.com:facser/Learning.git (push) $ git remote add origin \u0026lt;Repository url\u0026gt; # 将远程仓库命名为 origin 并关联本地仓库 一个本地仓库可以关联多个远程仓库 本地仓库可以提交代码到任意一个已关联的远程仓库 使用克隆后, 该远程仓库默认被命名为 origin .gitignore 忽略指定文件, 不对其追踪和提交, 文件名固定为 .gitignore, 项目内可创建多个\n1 2 3 4 5 6 7 $ cat .gitignore \u0026gt; *.pyc # 忽略当前项目内所有 .pyc 结尾的文件 \u0026gt; !main.pyc # 强制跟踪所有 main.pyc \u0026gt; /*.log # 忽略当前目录下 .log 结尾文件, 不影响上层的文件 \u0026gt; temp/ # 忽略整个项目内所有 temp 文件夹 \u0026gt; /lib/*.pyc # 忽略当前 lib 目录 下一级的 pyc 文件, lib 下多层目录不受影响 \u0026gt; lib/**/.pyc # 忽略项目内所有 lib 文件夹内的 pyc 文件 SSH key 密钥 本地仓库推送代码到远端时, git 会要求用户输入用户名和密码, 设置 ssh key 即可免密码推送\n生成密钥 密钥 linux windows id_rsa (私钥) /root/.ssh/id_rsa C:\\Users\\\u0026lt;user\u0026gt;\\.ssh id_rsa.pub (公钥) /root/.ssh/id_rsa.pub C:\\Users\\\u0026lt;user\u0026gt;\\.ssh 生成两个密钥文件, 将公钥放到代码托管平台的账号设置中\n1 2 3 4 5 $ ssh-keygen # 自动生成密钥 $ ssh-keygen -t rsa -C \u0026#34;key message\u0026#34; # 生成 rsa 类型带 key 注释信息的密钥 $ cat ~/.ssh/id_rsa.pub # 公钥以 ssh-rsa 开头, 注释信息结尾 \u0026gt; ssh-rsa xxx....xxx key message 密钥由系统生成, 放入用户设置, 所以是系统和账户绑定 系统下的本地仓库推送代码到该账户使用 ssh 链接时即可免密 ","date":"2022-07-13T21:23:54Z","permalink":"https://facsert.github.io/p/git-%E8%BF%9C%E7%AB%AF%E4%BB%93%E5%BA%93/","title":"Git 远端仓库"},{"content":"介绍 本地仓库是\n创建 使用 git init 创建本地仓库, 在创建位置会创建 .git 隐藏文件夹 仓库所有配置及版本文件均保存在 .git 文件夹中\n1 2 3 4 5 6 7 8 $ mkdir -p ~/Desktop/repository # 在左面创建 repository 文件夹 $ cd ~/Desktop/repository # 进入 repository 文件夹 $ git init # 在 repository 目录下创建本地仓库 \u0026gt; Initialized empty Git repository in /root/Desktop/repository/.git/ $ ls -a # 查看创建的隐藏文件夹 \u0026gt; . .. .git 状态 git-status - Show the working tree status\ngit 用一下3种描述表示文件状态, 进一步可划分为未追踪和已追踪 工作区 \u0026ndash; git add \u0026ndash;\u0026gt; 暂存区 \u0026ndash; git commit \u0026ndash;\u0026gt; 本地仓库\n区域 描述 状态 Untracked files 新增文件 文件处于工作区, 未被追踪 Changes not staged for commit 有新修改的文件 文件处于工作区, 新修改未被追踪 Changes to be committed 无修改的文件 文件处于暂存区, 修改已追踪 1 2 3 4 5 6 7 8 9 $ git status # 查看本地仓库状态, 有新增文件未被记录 \u0026gt; Untracked files: # 新增文件 first_file.txt \u0026gt; first_file.txt \u0026gt; \u0026gt; Changes to be committed: # ADD 新文件 first_file.txt, 待 commit \u0026gt; new file: first_file.txt \u0026gt; \u0026gt; Changes not staged for commit: # 已被记录文件 first_file.txt，又有新修改但未被记录 \u0026gt; modified: first_file.txt git-add - Add file contents to the index\n追踪本地仓库的修改, 追踪的文件内容进入暂存区, 等待新的 ADD 覆盖或者 commit 生成版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ git add \u0026lt;file\u0026gt; # 记录指定文件修改 $ git add . # 记录当前目录下所有文件修改(上层文件未记录) $ git add --all # 记录仓库目录下所有文件修改(推荐) $ git status # 新增文件已被记录 \u0026gt; Changes not staged for commit: # 文件被修改但未被记录 modified: first_file.txt $ git add --all # 记录 repository 目录下所有修改 $ git status \u0026gt; Changes to be committed: # 文件修改已被记录, 待 commit modified: first_file.txt git-commit - Record changes to the repository\n将暂存区的文件内容生成可回溯的版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ git commit -m \u0026#34;\u0026lt;commit message\u0026gt;\u0026#34; # message 较短描述可直接填写 $ git commit -s # message 较长, 使用默认编辑器编辑 commit $ git commit --amend # 在上次 commit 基础上修改, 并替换原来的 commit $ git commit --amend --no-edit # 使用上次 commit 且不修改, 即本次 commit 和上次合并 $ git checkout --\u0026lt;file\u0026gt; # 撤销工作区的修改, 回到上次 commit 状态 $ git status \u0026gt; Changes to be committed: # 文件修改已被记录, 待 commit modified: first_file.txt $ git commit -m \u0026#34;first commit\u0026#34; # 暂存区文件内容生成版本 \u0026gt; 1 file changed, 1 insertion(+) $ git status # 修改已保存生成版本 \u0026gt; nothing to commit, working tree clean $ git log # 查看 commit 版本信息 \u0026gt; commit 38c1df5cf2bed00f5b7365ee4913916e25238009 (HEAD -\u0026gt; master) \u0026gt; Author: facser \u0026lt;root@facser\u0026gt; \u0026gt; Date: Mon Feb 13 20:42:18 2023 +0800 first commit # 本次版本描述 git-log - Show commit logs\n1 2 3 4 5 $ git log # 显示所有 commit 的版本的详细信息 $ git log --pretty=oneline # 显示 commit 版本的简略信息 \u0026gt; 38c1df5cf2bed00f5b7365ee4913916e25238009 (HEAD -\u0026gt; master) first commit \u0026gt; d2716b6e88567c3fdfe390580d48ca82b581c04f (HEAD -\u0026gt; master) add file and line git-reset - Reset current HEAD to the specified state\n通过 git log 定位回退的版本, 使用 git reset 执行回退\n1 2 3 4 $ git reset --hard HEAD \u0026lt;commit number\u0026gt; # 回到指定 commit 版本 $ git reset --hard HEAD^ # 回退到上个版本 \u0026gt; HEAD is now at d2716b6 add file and line git-diff - Show changes between commits, commit and working tree, etc\n未被追踪(not ADD)和已追踪(ADD)内容进行比对, 已被追踪则不比对\n1 2 3 4 5 6 7 8 $ git diff \u0026gt; diff --git a/file b/file # file 已 ADD 和未 ADD 比对 \u0026gt; index 08fe272..06fcdd7 100644 \u0026gt; --- a/file # - 开头是被追踪的内容 \u0026gt; +++ b/file # + 开头是未被追踪的内容 \u0026gt; @@ -1 +1,2 @@ \u0026gt; first line \u0026gt; +second line # 新增行 git-push - Update remote refs along with associated objects\n将本地所有新增的 commit 推送到远端仓库\n1 2 3 4 5 6 $ git push origin master # 提交所有 commit 到 origin 仓库的 master 分支 $ git push -u origin master # 将 origin 仓库 master 分支作为拉取和推送的默认值 $ git push \u0026lt;repo\u0026gt; \u0026lt;branch\u0026gt; # 使用过 -u 后可以省略仓库和分支 \u0026gt; To github.com:facser/Learning.git 309ae9f..74beac3 main -\u0026gt; main ","date":"2022-07-10T21:13:54Z","permalink":"https://facsert.github.io/p/git-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/","title":"Git 本地仓库"},{"content":"Git 介绍 Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency\nGit 是一个开源的文件版本控制器\n在云端仓库, 本地仓库, 任意位置传输文件 记录代码和文件的改动及状态 回溯到已记录的某个节点 分布式版本控制器 安装 Git 官网下载安装\n1 2 3 4 5 $ git --version # 检查 git 是否安装 \u0026gt; git version 1.8.3.1 $ yum install git # Centos Redhat 系统使用 yum 安装 $ sudo apt-get install git # Ubuntu Debian 系统使用 apt 配置 git-config - Get and set repository or global options\n将文件或代码上传云端时, 需要设置用户名和邮箱, Git 用户和邮箱有 3 个等级\nleve file introduce system /etc/gitconfig 系统上每一个用户及他们仓库的通用配置(不常用) global ~/.gitconfig 当前系统用户, 这会对你系统上所有的仓库生效 local .git/config 在仓库内默认使用 local 配置(优先级最高) 查看 git 配置 1 2 3 4 5 6 7 8 $ git config --list --show-origin # 查看所有配置及所在的文件, 早期版本不支持 $ git config --system --list # 查看系统的 git 配置 $ git config --global --list # 查看系统当前用户的 git 配置 $ git config --local --list # 查看当前库的 git 配置 $ git config --list # 列出上述所有配置, 可能出现重复项 \u0026gt; user.name=facser \u0026gt; core.editor=vim 修改 git 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ git config -e # 编辑配置文件 $ git config --global core.editor vim # 修改系统当前用户的 git 编辑器为 vim $ git config --global color.ui true # 系统当前用户的 git 输出显示颜色 $ git config --global commit.template \u0026lt;file\u0026gt; # 设置 commit 签名模板 $ git config --global user.name facser # 设置系统当前的 git 用户名为 facser $ git config user.name # 查看当前使用的 git 用户名 $ git config --global user.email abc@email # 设置系统当前的 git 邮箱为 abc@email $ git config user.email # 查看当前使用的 git 用户名 $ git config --list # 列出上述所有配置, 可能出现重复项 \u0026gt; user.name=facser \u0026gt; user.email=abc@email \u0026gt; core.editor=vim 仓库 区域 位置 介绍 本地仓库 当前 .git 记录文件当前状态生成一个版本并保存至本地仓库 远程仓库 网络平台 将当前记录的所有版本上传到远程仓库 本地仓库 在本地任意位置使用 git init 即可创建一个本地仓库\n工作区 \u0026ndash; git add \u0026ndash;\u0026gt; 暂存区 \u0026ndash; git commit \u0026ndash;\u0026gt; 本地仓库\n1 2 3 4 5 6 7 8 9 10 11 $ git init # 初始化本地仓库 $ git add --all # 追踪本地仓库所有修改 $ git commit -m \u0026#34;version message\u0026#34; # 生成可回溯的版本 $ git push \u0026lt;repository name\u0026gt; \u0026lt;branch name\u0026gt; # 将本地仓库分支所有版本推送到远程仓库对应分支 $ git log # 查看记录的版本 \u0026gt; commit d2716b6e88567c3fdfe390580d48ca82b581c04f (HEAD -\u0026gt; master) \u0026gt; Author: facser \u0026lt;root@facser\u0026gt; \u0026gt; Date: Mon Jan 30 22:09:15 2023 +0800 \u0026gt; \u0026gt; version message 远程仓库 将本地仓库上传到远程仓库, 或从远程仓库下载文件到本地\n1 2 3 4 5 6 7 8 9 10 $ git clone \u0026lt;repository link\u0026gt; # 克隆远程仓库项目到本地 $ git add --all # 追踪本地仓库所有修改 $ git commit -m \u0026#34;version message\u0026#34; # 生成可回溯的版本 $ git push \u0026lt;repository name\u0026gt; \u0026lt;branch name\u0026gt; # 将本地仓库分支所有版本推送到远程仓库对应分支 $ git remote -v # 产看远程仓库 \u0026gt; origin git@github.com:facser/Learning.git (fetch) \u0026gt; origin git@github.com:facser/Learning.git (push) $ git remote add origin \u0026lt;Repository url\u0026gt; # 将远程仓库命名为 origin 并关联本地仓库 ","date":"2022-07-08T21:08:54Z","permalink":"https://facsert.github.io/p/git-%E5%9F%BA%E7%A1%80/","title":"Git 基础"},{"content":"","date":"2022-05-27T21:20:45Z","permalink":"https://facsert.github.io/p/c-%E5%AD%97%E7%AC%A6/","title":"C 字符"},{"content":"整形 1 2 3 4 5 6 7 8 9 10 11 12 13 int main(void) { short int short_int = 1; int normal_int = 2; long int long_int = 3; printf(\u0026#34;size of short int : %zu\\n\u0026#34;, sizeof(short_int)); printf(\u0026#34;size of normal int: %zu\\n\u0026#34;, sizeof(normal_int)); printf(\u0026#34;size of long int : %zu\\n\u0026#34;, sizeof(long_int)); } size of short int : 2 size of normal int: 4 size of long int : 8 sizeof : 返回变量占用的存储大小(单位: 字节)\n关键字 signed unsigned 含义 有符号(包含负数, 默认值) 无符号(从 0 开始, 不包含负数) 1 2 3 4 5 6 int num = 2; // 省略 signed, 默认有符号 signed num = 2; // 省略 int, int 可以省略 signed int num = 2; // 全写, 与上述两种声明效果一致 unsigned short x; // unsigned short int; 省略 int long y; // unsigned long int; 省略 signed 和 int 类型 大小 范围 signed short int 2 个字节 (16 位) -(2^15) ~ (2^15)-1 unsigned short int 2 个字节 (16 位) 0 ~ (2^16)-1 signed int 4 个字节 (32 位) -(2^31) ~ (2^31)-1 unsigned int 4 个字节 (32 位) 0 ~ (2^32)-1 signed long int 8 个字节 (64 位) -(2^63) ~ (2^63)-1 unsigned long int 8 个字节 (64 位) 0 ~ (2^64)-1 最值 C 语言最值的定义 /usr/include/limits.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Minimum and maximum values a `signed short int\u0026#39; can hold. */ # define SHRT_MIN (-32768) # define SHRT_MAX 32767 /* Maximum value an `unsigned short int\u0026#39; can hold. (Minimum is 0.) */ # define USHRT_MAX 65535 /* Minimum and maximum values a `signed int\u0026#39; can hold. */ # define INT_MIN (-INT_MAX - 1) # define INT_MAX 2147483647 /* Maximum value an `unsigned int\u0026#39; can hold. (Minimum is 0.) */ # define UINT_MAX 4294967295U /* Minimum and maximum values a `signed long int\u0026#39; can hold. */ # if __WORDSIZE == 64 # define LONG_MAX 9223372036854775807L # else # define LONG_MAX 2147483647L # endif # define LONG_MIN (-LONG_MAX - 1L) /* Maximum value an `unsigned long int\u0026#39; can hold. (Minimum is 0.) */ # if __WORDSIZE == 64 # define ULONG_MAX 18446744073709551615UL # else # define ULONG_MAX 4294967295UL # endif 引入头文件, 通过变量名使用最值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;limits.h\u0026gt; printf(\u0026#34;signed short int min : %d \\n\u0026#34;, SHRT_MIN); printf(\u0026#34;signed short int max : %d \\n\u0026#34;, SHRT_MAX); printf(\u0026#34;signed int min : %d \\n\u0026#34;, INT_MIN); printf(\u0026#34;signed int max : %d \\n\u0026#34;, INT_MAX); printf(\u0026#34;signed long int min : %ld \\n\u0026#34;, LONG_MIN); printf(\u0026#34;signed long int max : %ld \\n\u0026#34;, LONG_MAX); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;unsigned short int max: %d \\n\u0026#34;, USHRT_MAX); printf(\u0026#34;unsigned int max: %u \\n\u0026#34;, UINT_MAX); printf(\u0026#34;unsigned long int max: %lu \\n\u0026#34;, ULONG_MAX); \u0026gt; signed short int min : -32768 \u0026gt; signed short int max : 32767 \u0026gt; signed int min : -2147483648 // 占位符对应类型，也有范围 \u0026gt; signed int max : 2147483647 // 变量只超出占位符范围会溢出，打印错误值 \u0026gt; signed long int min : -9223372036854775808 // long 超出 %d 范围，需要使用 long 整形占位符 %ld \u0026gt; signed long int max : 9223372036854775807 // %d 的范围即为 signed int 的范围 \u0026gt; unsigned short int max: 65535 \u0026gt; unsigned int max: 4294967295 // 超出 signed 范围, 使用 %u 无符号整型 \u0026gt; unsigned long int max: 18446744073709551615 // 超出 signed long 范围, 使用 %lu 无符号长整型 1 2 printf(\u0026#34;long int: %d \\n\u0026#34;, LONG_MAX); // long 范围超出 %d 范围 \u0026gt; long int: -1 // 溢出, 打印错误 进制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int bin = 0b10; // 二进制 (低版本编译器不支持) int oct = 010; // 八进制, 0 开头 int ten = 10; // 十进制 int hex = 0x10; // 十六进制 printf(\u0026#34; oct dec hex \\n\u0026#34;); printf(\u0026#34;bin %2o %2d %2x \\n\u0026#34;, bin, bin, bin); printf(\u0026#34;oct %2o %2d %2x \\n\u0026#34;, oct, oct, oct); // %o 八进制形式打印 printf(\u0026#34;dec %2o %2d %2x \\n\u0026#34;, ten, ten, ten); // %d 十进制形式打印 printf(\u0026#34;hex %2o %2d %2x \\n\u0026#34;, hex, hex, hex); // %x 十六进制形式打印 \u0026gt; oct dec hex \u0026gt; bin 2 2 2 \u0026gt; oct 10 8 8 \u0026gt; dec 12 10 a \u0026gt; hex 20 16 10 浮点数 浮点数的存储方式与整数不一致，浮点数采用科学计数法存储浮点数\nfloat = (+/-) (1 + 尾数) * (2^指数)\n类型 符号位 指数位 尾数 float 1 位(31) 8 位(23-30) 23 位(0-22) double 1 位(63) 11 位(52-62) 52 位(0-52) 指数(8 位): 2 的指数(-128 ~ 127), 决定范围 尾数(23位): 小数点后的数值(0 ~ 1), 决定精度\n最大值(符号取正, 尾数接近 1, 指数 127): (+1)(1+1) 2^127 = 2^128 精度: 8388608(2^23), 共 7 位, 第 7 位未能覆盖, 所以仅能保证 6 位\n1 2 3 4 5 6 float f = 3; printf(\u0026#34;float %f size: %zu \\n\u0026#34;, f, sizeof(f)); \u0026gt; float 3.000000 size: 4 printf(\u0026#34;float %.20f \\n\u0026#34;, 0.1+0.2); // 打印浮点数小数点后 20 位 \u0026gt; float 0.30000000000000004441 // 浮点数精度问题, 0.1+0.2 != 0.3 类型转换 数字类型之间可以互相转换, 转换的前后类型包含关系可能会导致精度损失或类型溢出\n隐式转换 1 2 3 4 5 6 7 8 9 float e = 2.718; int num = e; // 浮点型转整形 printf(\u0026#34;num: %d\\n\u0026#34;, num); \u0026gt; num: 2 // 小数部分丢失 int num = 32768; short s_num = num; // int 转 short int, signed short int (-32768, 32767) printf(\u0026#34;num: %d\\n\u0026#34;, s_num); \u0026gt; num: -32768 // 数值溢出, 可能导致意想不到的问题 显式转换 显式转换: (type)variable\n1 2 3 int num = 3; printf(\u0026#34;num: %f\\n\u0026#34;, (float)num); // num 强制转为 float 类型 \u0026gt; num: 3.000000 布尔值 C99 标准开始添加 stdbool.h 引入了 _Bool 类型 布尔类型本质还是 0 和 1\n1 2 3 #define bool _Bool #define true 1 #define false 0 1 2 3 4 5 6 7 bool normal; bool flag = true; printf(\u0026#34;bool normal: %d \\n\u0026#34;, normal); printf(\u0026#34;bool flag : %d \\n\u0026#34;, flag); \u0026gt; bool normal: 0 \u0026gt; bool flag : 1 ","date":"2022-05-27T20:20:45Z","permalink":"https://facsert.github.io/p/c-%E6%95%B4%E5%BD%A2/","title":"C 整形"},{"content":"示例 创建 main.c 文件，写入代码\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; // 引入标准库 stdio.h (/usr/include/) int main(void) { // 定义执行入口, 入口函数名称固定为 main printf(\u0026#34;hello world!\u0026#34;); // 使用 stdio.h 中的 printf 函数 return 0; } 使用 GCC 编译\n1 2 3 $ gcc main.c -o main # 编译 main.c 文件成可执行文件 main $ ./main # 执行 main \u0026gt; hello world! # 显示执行结果 C 是编译性语言, C 代码需要编译成可执行文件之后才能运行\n1 2 3 4 5 6 main.c --1--\u0026gt; main.i --2--\u0026gt; main.s --3--\u0026gt; main.o --4--\u0026gt; main # main.c -\u0026gt; main.i 预处理, 展开头文件，宏替换，全掉注释，条件编译 # main.i -\u0026gt; main.s 编译 优化转化成汇编代码 # main.s -\u0026gt; main.o 汇编转成机器码 # main.o -\u0026gt; main 链接到一起生产可执行文件 版本 C 版本按照发布时间定义: C89/C90, C99, C11, C17, C2X C 使用 gcc 编译, 不同 gcc 版本默认使用不同标准编译\n1 2 3 4 5 $ gcc -dM -E - \u0026lt; /dev/null | grep \u0026#34;STDC_VERSION\u0026#34; # 查看默认使用的 C 标准 \u0026gt; #define __STDC_VERSION__ 199901L # 默认使用 C99 标准编译 \u0026gt; #define __STDC_VERSION__ 201112L # 默认使用 C11 标准编译 \u0026gt; #define __STDC_VERSION__ 201710L # 默认使用 C17 标准编译 强制使用 -std=\u0026lt;cxx\u0026gt; 标准编译\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ cat -n main.c # 写一个 for 循环 \u0026gt; 1 #include \u0026lt;stdio.h\u0026gt; \u0026gt; 2 \u0026gt; 3 int main() { \u0026gt; 4 for(int i=0; i \u0026lt; 3; i++) { \u0026gt; 5 printf(\u0026#34;index: %d \\n\u0026#34;, i); \u0026gt; 6 } \u0026gt; 7 } $ gcc main.c -o main -std=c89 # 强制使用 C89/C90(同一标准不同叫法) 编译 \u0026gt; main.c: In function ‘main’: \u0026gt; main.c:5:5: error: ‘for’ loop initial declarations are only allowed in C99 or C11 mode \u0026gt; for(int i=0; i \u0026lt; 3; i++) { # C89/C90 标准不支持在 for 循环内定义变量 \u0026gt; ^~~ # 提示使用 C99 或以上的标准编译 \u0026gt; main.c:5:5: note: use option -std=c99, -std=gnu99, -std=c11 or -std=gnu11 to compile your code 格式 1 2 3 4 5 6 7 8 9 int num; // 声明变量 \u0026lt;类型\u0026gt; \u0026lt;变量名\u0026gt;; 分号是必须的 num = 1; // 变量必须声明后才可以赋值 int num = 2; // 变量声明并赋值, 等号两边空格不是必须 int // 语句以分号结尾, 编译器会忽略换行 num = 3; 1 2 3 4 int add (int x, int y) { // \u0026lt;return type\u0026gt; \u0026lt;function name\u0026gt; (\u0026lt;arg type\u0026gt; \u0026lt;arg name\u0026gt;) { int sum = x + y; // code block return sum; // code block } // } function end 关键字 1 2 3 4 5 6 7 8 9 branch: if else switch case default loop: for do while jump: break goto return continue Functions: sizeof typedef Type: void int char float double union enum struct Modifiers: short long signed unsigned const static auto register extern volatile ","date":"2022-05-27T18:20:45Z","permalink":"https://facsert.github.io/p/c-%E5%9F%BA%E7%A1%80/","title":"C 基础"}]